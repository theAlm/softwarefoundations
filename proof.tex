\ifpdf
\special{pdf: out 2 << /Title 
(Einige formale Grundlagen von Beweistechniken) 
/Dest [ @thispage /FitH @ypos ] >>}
\fi
\section{Einige formale Grundlagen von Beweistechniken}
Praktisch arbeitende Informatiker glauben oft völlig ohne (formale)
Beweistechniken auskommen zu können. Dabei meinen sie sogar, dass
formale Beweise keinerlei Berechtigung in der Praxis der Informatik
haben und bezeichnen solches Wissen als "`in der Praxis irrelevantes
Zeug, das nur von und für seltsame Wissenschaftler erfunden
wurde"'. Oft stellen sie sich auf den Standpunkt, dass die Korrektheit
von Programmen und Algorithmen durch "'Lassen wir es doch mal laufen
und probieren es aus!"' ($\triangleq$ Testen) belegt werden könne.

Theoretiker, die sich mit den Grundlagen der Informatik beschäftigen,
vertreten oft den Standpunkt, dass die Korrektheit \emph{jedes}
Programms bewiesen werden muss. Wahrscheinlich ist die Position
zwischen diesen beiden Extremen richtig, denn zum einen ist der
formale Beweis von (großen) Programmen oft nicht praktikabel (oder
möglich) und zum anderen kann das Testen mit einer (relativ kleinen)
Menge von Eingaben sicherlich nicht belegen, dass ein Programm
vollständig den Spezifikationen entspricht. Im praktischen Einsatz ist
es dann oft mit Eingaben konfrontiert, die zu einer fehlerhaften
Reaktion führen oder es sogar abstürzen\footnote{Dies wird
eindrucksvoll durch viele Softwarepakete und verbreitete
Betriebssysteme im PC-Umfeld belegt.} lassen. Bei einfacher
Anwendersoftware sind solche Fehler ärgerlich, aber oft zu
verschmerzen. Bei sicherheitskritischer Software (z.B.~bei der
Regelung von Atomkraftwerken, Airbags und Bremssystemen in Autos oder
bei der Steuerung von Raumsonden) gefährden solche Fehler menschliches
Leben oder führen zu extrem hohen finanziellen Verlusten und müssen
deswegen unbedingt vermieden werden.

Für den Praktiker bringen Kenntnisse über formale Beweise aber noch
andere Vorteile.  Einige Beweistechniken beschreiben direkt den zur
Lösung benötigten Algorithmus, d.h.~eigentlich wird die Richtigkeit
einer Aussage durch die (implizite) Angabe eines Algorithmus
gezeigt. Aber es gibt noch einen anderen Vorteil. Ist der umzusetzende
Algorithmus komplex (z.B.~aufgrund einer komplizierten
Schleifenstruktur oder einer verschachtelten Rekursion), so ist es
unwahrscheinlich, eine korrekte Implementation an den Kunden liefern
zu können, ohne die Hintergründe ($\triangleq$ Beweis) verstanden zu
haben. All dies zeigt, dass auch ein praktischer Informatiker
Einblicke in Beweistechniken haben solle. Interessanterweise zeigt die
Erfahrung im praktischen Umfeld auch, dass solches (theoretisches)
Wissen über die Hintergründe oft zu klarer strukturierten und
effizienteren Programmen führt.

\ifpdf
\special{pdf: out 3 << /Title 
(Direkte Beweise)
/Dest [ @thispage /FitH @ypos ] >>}
\fi
\subsection{Direkte Beweise}
Um einen direkten Beweis zu führen, müssen wir, beginnend von einer
initialen Aussage ($\triangleq$ Hypothese), durch Angabe einer Folge
von (richtigen) Zwischenschritten zu der zu beweisenden Aussage
($\triangleq$ Folgerung) gelangen. Jeder Zwischenschritt ist dabei
entweder unmittelbar klar oder muss wieder durch einen weiteren
(kleinen) Beweis belegt werden. Dabei müssen nicht alle Schritt völlig
formal beschrieben werden, sondern es kommt darauf an, dass sich dem
Leser die eigentliche Strategie erschließt.

\begin{theorem}
\label{ExpoGTSquare}
Sei $n \in \N$. Falls $n \ge 4$, dann ist $2^n \ge n^2$.
\end{theorem}

Wir müssen also, in Abhängigkeit des Parameters $n$, die Richtigkeit
dieser Aussage belegen. Einfaches Ausprobieren ergibt, dass $2^4 = 16
\ge 16 = 4^2$ und $2^5 = 32 \ge 25 = 5^2$, d.h.~intuitiv scheint die
Aussage richtig zu sein. Wir wollen die Richtigkeit der Aussage nun
durch eine Reihe von (kleinen) Schritten belegen:

\begin{proof}

Wir haben schon gesehen, dass die Aussage für $n = 4$ und $n = 5$
richtig ist. Erhöhen wir $n$ auf $n + 1$, so verdoppelt sich der Wert
der linken Seite der Ungleichung von $2^n$ auf $2 \cdot 2^n =
2^{n+1}$. Für die rechte Seite ergibt sich ein Verhältnis von
$(\frac{n+1}{n})^2$. Je größer $n$ wird, desto kleiner wird der Wert
$\frac{n+1}{n}$, d.h.~der maximale Wert ist bei $n = 4$ mit $1.25$
erreicht. Wir wissen $1.25^2 = 1.5625$. D.h.~immer wenn wir $n$ um
eins erhöhen, verdoppelt sich der Wert der linken Seite, wogegen sich
der Wert der rechten Seite um maximal das $1.5625$ fache erhöht. Damit
muss die linke Seite der Ungleichung immer größer als die rechte Seite
sein.\qed
\end{proof}

\bigskip

Dieser Beweis war wenig formal und sehr ausführlich. D.h.~es stellt
sich die Frage: "`Wie formal und ausführlich muss ein Beweis sein?"'
Diese Frage kann so einfach nicht beantwortet werden, denn das hängt
u.a.~davon ab, welche Lesergruppe durch den Beweis von der Richtigkeit
einer Aussage überzeugt werden soll und wer den Beweis
schreibt. D.h.~ein Beweis für ein Übungsblatt sollte auch auf
Kleinigkeiten Rücksicht nehmen, wogegen ein solcher Stil für eine
wissenschaftliche Zeitschrift vielleicht nicht angebracht wäre. Nun
noch eine Bemerkung zum Thema "`Formalismus"': Die menschliche Sprache
ist unpräzise, mehrdeutig und Aussagen können oft auf verschiedene
Weise interpretiert werden. Diese Defizite sollen
Formalismen\footnote{In diesem Zusammenhang sind Programmiersprachen
auch Formalismen, die eine präzise Beschreibung von Algorithmen
erzwingen und die durch einen Compiler verarbeitet werden können.}
ausgleichen, d.h.~die Antwort muss lauten: "`So viele Formalismen wie
notwendig und so wenige wie möglich!"'. Durch Übung und Praxis lernt
man die Balance zwischen diesen Anforderungen zu halten und es zeigt
sich bald, dass "`Geübte"' die formale Beschreibung sogar wesentlich
leichter verstehen.

\bigskip

Oft kann man andere, schon bekannte, Aussagen dazu verwenden, die
Richtigkeit einer Aussage zu belegen.

\begin{theorem}
\label{ExpoGTSquare2}
Sei $n \in \N$ die Summe von $4$ Quadratzahlen, die größer als $0$
sind, dann ist $2^n \ge n^2$.
\end{theorem}

\begin{proof}
Die Menge der Quadratzahlen ist $Q = \set{0, 1, 4, 9, 16, 25, 36,
  \dots}$, d.h.~$1$ ist die kleinste Quadratzahl, die größer als $0$
ist. Damit muss unsere Summe von $4$ Quadratzahlen größer als $4$
sein. Die Aussage folgt direkt aus Theorem \ref{ExpoGTSquare}.
\qed
\end{proof}

\ifpdf
\special{pdf: out 4 << /Title 
(Die Kontraposition)
/Dest [ @thispage /FitH @ypos ] >>}
\fi
\subsubsection{Die Kontraposition}

Mit Hilfe von direkten Beweisen haben wir Zusammenhänge der Form
"`Wenn Aussage $H$ richtig ist, dann folgt daraus die Aussage $C$"'
untersucht. Manchmal ist es schwierig einen Beweis für eine solchen
Zusammenhang zu finden. Völlig gleichwertig ist die Behauptung "`Wenn
die Aussage $C$ falsch ist, dann ist die Aussage $H$ falsch"' und oft
ist eine solche Aussage leichter zu zeigen.

Die Kontraposition von Satz \ref{ExpoGTSquare} ist also die folgende
Aussage: "`Wenn nicht $2^n \ge n^2$, dann gilt nicht $n \ge 4$."'. Das
entspricht der Aussage: "`Wenn $2^n < n^2$, dann gilt $n < 4$."', was
offensichtlich zu der ursprünglichen Aussage von
Satz \ref{ExpoGTSquare} gleichwertig ist.

\ifpdf
\special{pdf: out 3 << /Title 
(Widerspruchsbeweise)
/Dest [ @thispage /FitH @ypos ] >>}
\fi
\subsection{Widerspruchsbeweise}
Obwohl die Technik der Widerspruchsbeweise auf den ersten Blick sehr
kompliziert erscheint, ist sie sehr mächtig und liefert oft sehr kurze
Beweise. Angenommen wir sollen die Richtigkeit einer Aussage "`aus der
Hypothese $H$ folgt $C$"' zeigen. Dazu beweisen wir, dass sich ein
Widerspruch ergibt, wenn wir, von $H$ und der Annahme, dass $C$ falsch
ist, ausgehen. Also war die Annahme falsch, und die Aussage $C$ muss
richtig sein.

Anschaulicher wird diese Beweistechnik durch folgendes Beispiel:
Nehmen wir einmal an, dass Alice eine bürgerliche Frau ist und deshalb
auch keine Krone trägt. Es ist klar, dass jede Königin eine Krone
trägt. Wir sollen nun beweisen, dass Alice keine Königin ist. Dazu
nehmen wir an, dass Alice eine Königin ist, d.h.~Alice trägt eine
Krone. Dies ist ein Widerspruch! Also war unsere Annahme falsch, und
wir haben gezeigt, dass Alice keine Königin sein kann.

\goodbreak
\noindent Der Beweis zu folgendem Satz verwendet diese Technik:
\begin{theorem}
Sei $S$ eine endliche Untermenge einer unendlichen Menge $U$. Sei $T$
das Komplement von $S$ bzgl.~$U$, dann ist $T$ eine unendliche Menge.
\end{theorem}

\begin{proof}
Hier ist unsere Hypothese "`$S$ endlich, $U$ unendlich und $T$
Komplement von $S$ bzgl.~$U$"' und unsere Folgerung ist "`$T$ ist
unendlich"'. Wir nehmen also an, dass $T$ eine endliche Menge ist. Da
$T$ das Komplement von $S$ ist, gilt $S \cap T = \emptyset$, also ist
$\cnt(S) + \cnt(T) = \cnt (S \cap T) + \cnt (S \cup T) = \cnt (S \cup
T) = n$, wobei $n$ eine Zahl aus $\N$ ist (siehe
Abschnitt \ref{cntSet}). Damit ist $S \cup T = U$ eine endliche
Menge. Dies ist ein Widerspruch zu unserer Hypothese! Also war die
Annahme "`$T$ ist endlich"' falsch. \qed
\end{proof}

\ifpdf
\special{pdf: out 3 << /Title 
(Der Schubfachschluss)
/Dest [ @thispage /FitH @ypos ] >>}
\fi
\subsection{Der Schubfachschluss}
\label{Schubfachschluss}
Der Schubfachschluss ist auch als \dindex{Dirichlets
Taubenschlagprinzip}\index{Taubenschlagprinzip} bekannt. 
Werden $k > n$ Tauben auf $n$ Boxen
verteilt, so gibt es mindestens eine Box in der sich wenigstens zwei
Tauben aufhalten. Allgemeiner formuliert sagt das Taubenschlagprinzip,
dass wenn $n$ Objekte auf $k$ Behälter aufgeteilt werden, dann gibt es
mindestens eine Box die $\lceil \frac{n}{k} \rceil$ Objekte enthält.

\begin{example}
Auf einer Party unterhalten sich $8$ Personen ($\triangleq$ Objekte),
dann gibt es mindestens einen Wochentag ($\triangleq$ Box) an dem
$\lceil \frac{8}{7} \rceil =2$ Personen aus dieser Gruppe Geburtstag
haben.
\end{example}

\ifpdf
\special{pdf: out 3 << /Title 
(Gegenbeispiele)
/Dest [ @thispage /FitH @ypos ] >>}
\fi
\subsection{Gegenbeispiele}
Im wirklichen Leben wissen wir nicht, ob eine Aussage richtig oder
falsch ist. Oft sind wir dann mit einer Aussage konfrontiert, die auf
den ersten Blick richtig ist und sollen dazu ein Programm
entwickeln. Wir müssen also entscheiden, ob diese Aussage wirklich
richtig ist, denn sonst ist evtl.~alle Arbeit umsonst und hat hohe
Kosten verursacht. In solchen Fällen kann man versuchen, ein einziges
Beispiel dafür zu finden, dass die Aussage falsch ist, um so unnötige
Arbeit zu sparen.

\bigskip

\noindent Wir zeigen, dass die folgenden Vermutungen falsch sind:
\begin{conjecture}
Wenn $p \in \N$ eine Primzahl ist, dann ist $p$ ungerade.
\end{conjecture}

\begin{counterexample}
Die natürliche Zahl 2 ist eine Primzahl und $2$ ist gerade. \qed
\end{counterexample}

\begin{conjecture}
Es gibt keine Zahlen $a,b \in \N$, sodass $a \textrm{ mod } b = b
\textrm{ mod } a$.
\end{conjecture}

\begin{counterexample}
Für $a = b = 2$ gilt $a \textrm{ mod } b = b \textrm{ mod } a = 0$. \qed
\end{counterexample}

\ifpdf
\special{pdf: out 3 << /Title 
(Induktionsbeweise und das Induktionsprinzip)
/Dest [ @thispage /FitH @ypos ] >>}
\fi
\subsection{Induktionsbeweise und das Induktionsprinzip}
Eine der wichtigsten Beweismethoden der Informatik ist das
Induktionsprinzip. Wir wollen jetzt nachweisen, dass für jedes $n \in
\N$ eine bestimmte Eigenschaft $E$ gilt. Wir schreiben kurz $E(n)$ für
die Aussage "`$n$ besitzt die Eigenschaft $E$"'.

\bigskip

\noindent\textbf{Induktionsprinzip:} 

\noindent Es gelten 
\indudef%
{$E(0)$}%
{Für $n \ge 0$ gilt, wenn $E(k)$ für $k \le n$ korrekt ist, dann ist auch $E(n+1)$ richtig.}

Dabei ist \textbf{\textsf{IA}} die Abkürzung für
\dindex{Induktionsanfang} und \textbf{\textsf{IS}} ist die Kurzform von
\dindex{Induktionsschritt}. Die Voraussetzung ($\triangleq$ Hypothese)
$E(k)$ ist korrekt für $k \le n$ und wird im Induktionsschritt
als \dindex{Induktionsvoraussetzung} benutzt
(kurz \textbf{\textsf{IV}}).

Es gibt verschiedene Versionen von Induktionsbeweisen. Die bekannteste
Version ist die vollständige Induktion, bei der Aussagen über
natürliche Zahlen gezeigt werden.

\ifpdf
\special{pdf: out 4 << /Title 
(Die vollständige Induktion)
/Dest [ @thispage /FitH @ypos ] >>}
\fi
\subsubsection{Die vollständige Induktion}

Wie in Piratenfilmen üblich, seien Kanonenkugeln in einer Pyramide mit
quadratischer Grundfläche gestapelt. Wir stellen uns die Frage,
wieviele Kugeln (in Abhängigkeit von der Höhe) in einer solchen
Pyramide gestapelt sind.

\begin{theorem}
\label{Pyramid}
Mit einer quadratische Pyramide aus Kanonenkugeln der Höhe $n \ge 1$
als Munition, können wir $\frac{n(n+1)(2n+1)}{6}$ Schüsse abgeben.
\end{theorem}

\goodbreak
\begin{proof}
Einfacher formuliert: wir sollen zeigen, dass $\sum\limits_{i=1}^n i^2 =
\frac{n(n+1)(2n+1)}{6}$.
\induproof%
{Eine Pyramide der Höhe $n = 1$ enthält $\frac{1 \cdot 2 \cdot 3}{6} =
  1$ Kugel. D.h.~wir haben die Eigenschaft für $n = 1$ verifiziert.}%
{Für $k \le n$ gilt $\sum\limits_{i=1}^k i^2 = \frac{k(k+1)(2k+1)}{6}$.}%
{%
Wir müssen nun zeigen, dass $\sum\limits_{i=1}^{n+1} i^2 =
\frac{(n+1)((n+1)+1)(2(n+1)+1)}{6}$ gilt und dabei muss die
Induktionsvoraussetzung $\sum\limits_{i=1}^n i^2 = \frac{n(n+1)(2n+1)}{6}$
benutzt werden.  

\begin{displaymath}
\begin{array}{rcl}
\sum\limits_{i=1}^{n+1}i^2 &=& \sum\limits_{i=1}^{n}i^2 + (n + 1)^2\\
&\stackrel{\text{\textbf{\textsf{IV}}}}{=}& \frac{n(n+1)(2n+1)}{6} +
(n^2 + 2n + 1)\\
&=& \frac{2n^3 + 3n^2+n}{6} + (n^2 + 2n + 1)\\
&=& \frac{2n^3 + 9n^2+13n + 6}{6}\\
&=& \frac{(n+1)(2n^2+7n+6)}{6} \quad (\star)\\
&=& \frac{(n+1)(n+2)(2n+3)}{6} \quad (\star\star)\\
&=& \frac{(n+1)((n+1) + 1)(2(n + 1) + 1)}{6}\\
\end{array}
\end{displaymath}
Die Zeile $\star$ (bzw.~$\star\star$) ergibt sich, indem man $2n^3 +
9n^2+13n + 6$ durch $n+1$ teilt (bzw.~$2n^2+7n+6$ durch $n+2$). \qed
}
\end{proof}

Solche Induktionsbeweise treten z.B.~bei der Analyse von Programmen
immer wieder auf.

\ifpdf
\special{pdf: out 4 << /Title 
(Induktive Definitionen)
/Dest [ @thispage /FitH @ypos ] >>}
\fi
\subsubsection{Induktive Definitionen}

Das Induktionsprinzip kann aber auch dazu verwendet werden,
(Daten-)Strukturen formal zu spezifizieren. Dazu werden in einem
ersten Schritt ($\triangleq$ Induktionsanfang) die "`atomaren"'
Objekte definiert und dann in einem zweiten Schritt die
zusammengesetzten Objekte ($\triangleq$ Induktionsschritt). Diese
Technik ist als \dindex{induktive Definition} bekannt.

\begin{example}
\noindent Ein Baum ist wie folgt definiert:
\indudef{Ein einzelner Knoten $w$ ist ein \emph{Baum} und $w$ ist die
  \emph{Wurzel} dieses Baums.}{Seien $T_1, T_2, \dots, T_n$ Bäume mit den
  Wurzeln $\enu{k}{1}{n}$ und $w$ ein einzelner neuer Knoten. Verbinden wir
$w$ mit allen Wurzeln $\enu{k}{1}{n}$, dann entsteht ein neuer Baum
  mit der Wurzel $w$.} 
\end{example}

\begin{example}
\label{induexp}
\noindent Ein arithmetischer Ausdruck ist wie folgt definiert:
\indudef{Jeder Buchstabe und jede Zahl ist ein arithmetischer
Ausdruck.}{Seien $E$ und $F$ Ausdrücke, so sind auch $E + F$, $E * F$
und $[E]$ Ausdrücke.}

\noindent D.h.~$x$, $x+y$, $[2*x + z]$ sind arithmetische Ausdrücke,
aber beispielsweise sind $x + $, $yy$, $][x+y$ sowie $x +* z$ keine
Ausdrücke im Sinn dieser Definition.
\end{example}

Bei diesem Beispiel ahnt man schon, dass solche Techniken zur präzisen
Definition von Programmiersprachen und Dateiformaten gute Dienste
leisten. Induktive Definitionen haben noch einen weiteren Vorteil,
denn man kann leicht Induktionsbeweise konstruieren, die Aussagen über
induktiv definierte Objekte belegen.


\ifpdf
\special{pdf: out 4 << /Title 
(Die strukturelle Induktion)
/Dest [ @thispage /FitH @ypos ] >>}
\fi
\subsubsection{Die strukturelle Induktion}

\begin{theorem}
\label{CntBrack}
Die Anzahl der öffnenden Klammern eines arithmetischen Ausdrucks stimmt
mit der Anzahl der schließenden Klammern überein.
\end{theorem}

\begin{proof}
Wir bezeichnen die Anzahl der öffnenden Klammern eines Ausdrucks $E$
mit $\cnt_[(E)$ und verwenden die analoge Notation $\cnt_](E)$ für die
Anzahl der schließenden Klammern.

\induproof%
{
Die einfachsten Ausdrücke sind Buchstaben und Zahlen. Die Anzahl der
öffnenden und schließenden Klammern ist in beiden Fällen gleich $0$.
}
{
Sei $E$ ein Ausdruck, dann gilt $\cnt_[(E) = \cnt_](E)$.
}
{
 Für einen Ausdruck $E + F$ gilt $\cnt_[(E + F) = \cnt_[(E
) +
 \cnt_[(F) \stackrel{\text{\textbf{\textsf{IV}}}}{=} \cnt_](E) +
 \cnt_](F) = \cnt_](E + F)$. Völlig analog zeigt man dies für $E *
 F$. Für den Ausdruck $[E]$ ergibt sich $\cnt_[([E]) = \cnt_[(E) + 1
 \stackrel{\text{\textbf{\textsf{IV}}}}{=} \cnt_](E) + 1 = \cnt_]([E])$.
 In jedem Fall ist die Anzahl der öffnenden Klammern gleich der Anzahl
 der schließenden Klammern.\qed
}
\end{proof}

\bigskip

Mit Hilfe von Satz \ref{CntBrack} können wir nun leicht ein Programm
entwickeln, das einen Plausibilitätscheck (z.B.~direkt in einem Editor)
durchführt und die Klammern zählt, bevor die Syntax von arithmetischen
Ausdrücken überprüft wird. Definiert man eine vollständige
Programmiersprache induktiv, dann werden ganz ähnliche
Induktionsbeweise möglich, d.h.~man kann die Techniken aus diesem
Beispiel relativ leicht auf die Praxis der Informatik übertragen.
