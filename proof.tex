\special{pdf: out 2 << /Title 
(Einige formale Grundlagen von Beweistechniken) 
/Dest [ @thispage /FitH @ypos ] >>}
\section{Einige formale Grundlagen von Beweistechniken}
Praktisch arbeitende Informatiker glauben oft völlig ohne (formale)
Beweistechniken auskommen zu können. Dabei meinen sie sogar, dass
formale Beweise keinerlei Berechtigung in der Praxis der Informatik
haben und bezeichnen solches Wissen als "`in der Praxis irrelevantes
Zeug, das nur von und für seltsame Wissenschaftler erfunden
wurde"'. Studenten in den ersten Semestern unterstellen sogar oft,
dass mathematische Grundlagen und Beweistechniken nur als "`Filter"'
dienen, um die Anzahl der Studenten zu reduzieren. Oft stellen sich
beide Gruppen sich auf den Standpunkt, dass die Korrektheit von
Programmen und Algorithmen durch "`Lassen wir es doch mal laufen und
probieren es aus!"' ($\triangleq$ Testen) belegt werden könne. Diese
Einstellung zeigt sich oft auch darin, dass Programme mit Hilfe einer
IDE schnell "`testweise"' übersetzt werden, in der Hoffnung oder
(schlimmer) in der Überzeugung, dass ein übersetzbares Programm immer
auch semantisch korrekt sei.

Theoretiker, die sich mit den Grundlagen der Informatik beschäftigen,
vertreten oft den Standpunkt, dass die Korrektheit \emph{jedes}
Programms rigoros \emph{bewiesen} werden muss. Wahrscheinlich ist die
Position zwischen diesen beiden Extremen richtig, denn zum einen ist
der formale Beweis von (großen) Programmen oft nicht praktikabel (oder
möglich) und zum anderen kann das Testen mit einer (relativ kleinen)
Menge von Eingaben sicherlich nicht belegen, dass ein Programm
vollständig den Spezifikationen entspricht. Im praktischen Einsatz ist
es dann oft mit Eingaben konfrontiert, die zu einer fehlerhaften
Reaktion führen oder es sogar abstürzen\footnote{Dies wird
eindrucksvoll durch viele Softwarepakete und verbreitete
Betriebssysteme im PC-Umfeld belegt.} lassen. Bei einfacher
Anwendersoftware sind solche Fehler ärgerlich, aber oft zu
verschmerzen. Bei sicherheitskritischer Software (z.B.~bei der
Regelung von Atomkraftwerken, Airbags und Bremssystemen in Autos, in
der Medizintechnik oder bei der Steuerung von Raumsonden) gefährden
solche Fehler menschliches Leben oder führen zu extrem hohen
finanziellen Verlusten und müssen deswegen unbedingt vermieden werden.

Für den Praktiker bringen Kenntnisse über formale Beweise aber noch
andere Vorteile. Viele Beweise beschreiben direkt den zur Lösung
benötigten Algorithmus, d.h.~eigentlich wird die Richtigkeit einer
Aussage durch die (implizite) Angabe eines Algorithmus gezeigt. Aber
es gibt noch einen anderen Vorteil. Ist der umzusetzende Algorithmus
komplex (z.B.~aufgrund einer komplizierten Schleifenstruktur oder
einer verschachtelten Rekursion), so ist es unwahrscheinlich, eine
korrekte Implementation an den Kunden liefern zu können, ohne die
Hintergründe ($\triangleq$ Beweis) verstanden zu haben. All dies
zeigt, dass auch ein praktischer Informatiker Einblicke in
Beweistechniken haben sollte. Interessanterweise zeigt die persönliche Erfahrung im
praktischen Umfeld auch, dass solches (theoretisches) Wissen über die
Hintergründe oft zu klarer strukturierten und effizienteren Programmen
führt.

Aus diesen Gründen sollen in den folgenden Abschnitten einige
grundlegende Beweistechniken mit Hilfe von Beispielen (unvollständig)
kurz vorgestellt werden.

\special{pdf: out 3 << /Title 
(Direkte Beweise)
/Dest [ @thispage /FitH @ypos ] >>}
\subsection{Direkte Beweise}
Um einen \dindex{direkten Beweis}\index{Beweis!direkt} zu führen,
müssen wir, beginnend von einer initialen Aussage ($\triangleq$
Hypothese), durch Angabe einer Folge von (richtigen) Zwischenschritten
zu der zu beweisenden Aussage ($\triangleq$ Folgerung) gelangen. Jeder
Zwischenschritt ist dabei entweder unmittelbar klar oder muss wieder
durch einen weiteren (kleinen) Beweis belegt werden. Dabei müssen
nicht alle Schritte völlig formal beschrieben werden, sondern es kommt
darauf an, dass sich dem Leser die eigentliche Strategie erschließt.

\goodbreak
\begin{theorem}
\label{ExpoGTSquare}
Sei $n \in \N$. Falls $n \ge 4$, dann ist $2^n \ge n^2$.
\end{theorem}

Wir müssen also, in Abhängigkeit des Parameters $n$, die Richtigkeit
dieser Aussage belegen. Einfaches Ausprobieren ergibt, dass $2^4 = 16
\ge 16 = 4^2$ und $2^5 = 32 \ge 25 = 5^2$, d.h.~intuitiv scheint die
Aussage richtig zu sein. Wir wollen die Richtigkeit der Aussage nun
durch eine Reihe von (kleinen) Schritten belegen:

\begin{proof}

Wir haben schon gesehen, dass die Aussage für $n = 4$ und $n = 5$
richtig ist. Erhöhen wir $n$ auf $n + 1$, so verdoppelt sich der Wert
der linken Seite der Ungleichung von $2^n$ auf $2 \cdot 2^n =
2^{n+1}$. Für die rechte Seite ergibt sich ein Verhältnis von
$(\frac{n+1}{n})^2$. Je größer $n$ wird, desto kleiner wird der Wert
$\frac{n+1}{n}$, d.h.~der maximale Wert ist bei $n = 4$ mit $1.25$
erreicht. Wir wissen $1.25^2 = 1.5625$. D.h.~immer wenn wir $n$ um
eins erhöhen, verdoppelt sich der Wert der linken Seite, wogegen sich
der Wert der rechten Seite um maximal das $1.5625$ fache erhöht. Damit
muss die linke Seite der Ungleichung immer größer als die rechte Seite
sein.\qed
\end{proof}

\bigskip

Dieser Beweis war nur wenig formal, aber sehr ausführlich und wurde
am Ende durch das Symbol "`$\#$"' markiert. Im Laufe der Zeit
hat es sich eingebürgert, das Ende eines Beweises mit einem besonderen
Marker abzuschließen.  Besonders bekannt ist hier
"`$\mathrm{qed}$"'\index{qed=$\mathrm{qed}$}, eine Abkürzung für die
lateinische Floskel "`quod erat demonstrandum"', die mit "`was zu
beweisen war"' übersetzt werden kann. In neuerer Zeit werden statt
"`$\mathrm{qed}$"' mit der gleichen Bedeutung meist die Symbole
"`$\Box$"' oder "`$\#$"' \index{$\#$}\index{$\Box$}\index{qed}
verwendet.

Nun stellt sich die Frage: "`Wie formal und ausführlich muss ein
Beweis sein?"' Diese Frage kann so einfach nicht beantwortet werden,
denn das hängt u.a.~davon ab, welche Lesergruppe durch den Beweis von
der Richtigkeit einer Aussage überzeugt werden soll und wer den Beweis
schreibt. Ein Beweis für ein Übungsblatt sollte auch auf Kleinigkeiten
Rücksicht nehmen, wogegen ein solcher Stil für eine wissenschaftliche
Zeitschrift vielleicht nicht angebracht wäre, da die potentielle
Leserschaft über ganz andere Erfahrungen und viel mehr
Hintergrundwissen verfügt. Nun noch eine Bemerkung zum Thema
"`Formalismus"': Die menschliche Sprache ist unpräzise, mehrdeutig und
Aussagen können oft auf verschiedene Weise interpretiert werden, wie das
tägliche Zusammenleben der Geschlechter eindrucksvoll demonstriert. Diese
Defizite sollen Formalismen\footnote{In diesem Zusammenhang sind
Programmiersprachen auch Formalismen, die eine präzise Beschreibung
von Algorithmen erzwingen und die durch einen Compiler verarbeitet
werden können.} ausgleichen, d.h.~die Antwort muss lauten: "`So viele
Formalismen wie notwendig und so wenige wie möglich!"'. Durch Übung
und Praxis lernt man die Balance zwischen diesen Anforderungen zu
halten und es zeigt sich bald, dass "`Geübte"' die formale
Beschreibung sogar wesentlich leichter verstehen.

\bigskip

Oft kann man andere, schon bekannte, Aussagen dazu verwenden, die
Richtigkeit einer (kompliziert wirkenden) Aussage zu belegen.

\goodbreak
\begin{theorem}
\label{ExpoGTSquare2}
Sei $n \in \N$ die Summe von $4$ Quadratzahlen, die größer als $0$
sind, dann ist $2^n \ge n^2$.
\end{theorem}

\begin{proof}
Die Menge der Quadratzahlen ist $\mathbb{Q} = \set{0, 1, 4, 9, 16, 25, 36,
  \dots}$, d.h.~$1$ ist die kleinste Quadratzahl, die größer als $0$
ist. Damit muss unsere Summe von $4$ Quadratzahlen größer als $4$
sein. Die Aussage folgt direkt aus Satz \ref{ExpoGTSquare}.
\qed
\end{proof}

\special{pdf: out 4 << /Title 
(Die Kontraposition)
/Dest [ @thispage /FitH @ypos ] >>}
\subsubsection{Die Kontraposition}
\label{KontraPos}
Mit Hilfe von direkten Beweisen haben wir Zusammenhänge der Form
"`Wenn Aussage $H$ richtig ist, dann folgt daraus die Aussage $C$"'
untersucht. Manchmal ist es schwierig einen Beweis für eine solchen
Zusammenhang zu finden. Völlig gleichwertig ist die Behauptung "`Wenn
die Aussage $C$ falsch ist, dann ist die Aussage $H$ falsch"' und oft
ist eine solche Aussage leichter zu zeigen.

Die \dindex{Kontraposition} von Satz \ref{ExpoGTSquare} ist also die
folgende Aussage: "`Wenn nicht $2^n \ge n^2$, dann gilt nicht $n \ge
4$."'. Das entspricht der Aussage: "`Wenn $2^n < n^2$, dann gilt $n <
4$."', was offensichtlich zu der ursprünglichen Aussage von
Satz \ref{ExpoGTSquare} gleichwertig ist.

Diese Technik ist oft besonders hilfreich, wenn man die Richtigkeit
einer Aussage zeigen soll, die aus zwei Teilaussagen zusammengesetzt
und die durch ein "`genau dann wenn"'\footnote{Oft wird "`genau dann
wenn"' durch \emph{\gdw}\index{gdw=\gdw} abgekürzt.} verknüpft sind. In diesem Fall
sind zwei Teilbeweise zu führen, denn zum einen muss gezeigt werden,
dass aus der ersten Aussage die zweite folgt und umgekehrt muss
gezeigt werden, dass aus der zweiten Aussage die erste folgt.

\begin{theorem}
Eine natürliche Zahl $n$ ist durch drei teilbar genau dann, wenn die
Quersumme ihrer Dezimaldarstellung durch drei teilbar ist.
\end{theorem}

\begin{proof}
Für die Dezimaldarstellung von $n$ gilt
\begin{displaymath}
n = \sum_{i=0}^k a_i \cdot 10^i, \text{wobei $a_i \in \set{0,1, \ldots
,9}$ ("`Ziffern"') und $0 \le i \le k$}.
\end{displaymath}
Mit $\mathrm{QS}(n)$ wird die Quersumme von $n$ bezeichnet,
d.h.~$\mathrm{QS}(n) = \sum_{i=0}^{k} a_i$. Mit Hilfe einer einfachen vollständigen
Induktion kann man zeigen, dass für jedes $i \ge 0$ ein $b \in \N$
existiert, sodass $10^i = 9 b + 1$. Damit gilt $n = \sum_{i=0}^k
a_i \cdot 10^i = \sum_{i=0}^k a_i (9 b_i + 1) = \mathrm{QS}(n) +
9 \sum_{i=0}^k a_i b_i$, d.h.~es existiert ein $c \in \N$, so dass $n
= \mathrm{QS}(n) + 9c$.

\bigskip

\noindent "`$\Rightarrow$"': Wenn $n$ durch $3$ teilbar ist, dann muss auch $\mathrm{QS}(n) + 9c$ durch $3$
teilbar sein. Da $9c$ sicherlich durch $3$ teilbar ist, muss auch
$\mathrm{QS}(n) = n - 9c$ durch $3$ teilbar sein.

\medskip

\noindent "`$\Leftarrow$"': Dieser Fall soll durch Kontraposition gezeigt
werden. Sei nun $n$ nicht durch $3$ teilbar, dann darf
$\mathrm{QS}(n)$ nicht durch $3$ teilbar sein, denn sonst wäre $n = 9c
+ \mathrm{QS}(n)$ durch $3$ teilbar.\qed
\end{proof}

\special{pdf: out 3 << /Title 
(Der Ringschluss) /Dest [ @thispage /FitH @ypos ] >>}
\subsection{Der Ringschluss}
\label{RingSchluss}
Oft findet man mehrere Aussagen, die zueinander äquivalent sind. Ein
Beispiel dafür ist Satz \ref{SetProof}. Um die Äquivalenz dieser
Aussagen zu beweisen, müssten jeweils zwei "`genau dann wenn"'
Beziehungen untersucht werden, d.h.~es werden vier Teilbeweise
notwendig. Dies kann mit Hilfe eines so
genannten \emph{Ringschlusses}\index{Ringschluss} abgekürzt werden,
denn es reicht zu zeigen, dass aus der ersten Aussage die zweite
folgt, aus der zweiten Aussage die dritte und dass schließlich aus der
dritten Aussage wieder die erste folgt. Im Beweis zu
Satz \ref{SetProof} haben wir deshalb nur drei anstatt vier
Teilbeweise zu führen, was zu einer Arbeitsersparnis führt. Diese
Arbeitsersparnis wird um so größer, je mehr äquivalente Aussagen zu
untersuchen sind. Dabei ist die Reihenfolge der Teilbeweise nicht
wichtig, solange die einzelnen Teile zusammen einen Ring bilden.

\begin{theorem}
\label{SetProof}
Seien $A$ und $B$ zwei beliebige Mengen, dann sind die folgenden drei
Aussagen äquivalent:
\begin{enumerate}[i)]
%
\item\label{SetProof1} $A \subseteq B$
%
\item\label{SetProof2} $A \cup B = B$
%
\item\label{SetProof3} $A \cap B = A$
%
\end{enumerate}
\end{theorem}

\begin{proof}
Im folgenden soll ein Ringschluss verwendet werden, um die Äquivalenz
der drei Aussagen zu zeigen:

\noindent "`\ref{SetProof1}) $\Rightarrow$ \ref{SetProof2})"': Da nach
Voraussetzung $A \subseteq B$ ist, gilt für jedes Element $a \in A$
auch $a \in B$, d.h.~in der Vereinigung $A \cup B$ sind alle Elemente
nur aus $B$, was $A \cup B = B$ zeigt.

\medskip

\noindent "`\ref{SetProof2}) $\Rightarrow$ \ref{SetProof3})"': Wenn
$A \cup B = B$ gilt, dann ergibt sich durch Einsetzen und mit den
Regeln aus Abschnitt \ref{SetOpSect} (Absorbtionsgesetz) direkt
$A \cap B = A \cap (A \cup B) = A$.

\medskip

\noindent "`\ref{SetProof3}) $\Rightarrow$ \ref{SetProof1})"': Sei
nun $A \cap B = A$, dann gibt es kein Element $a \in A$ für das
$a \not\in B$ gilt. Dies ist aber gleichwertig zu der Aussage
$A \subseteq B$. 

Damit hat sich ein Ring von Aussagen "`\ref{SetProof1})
$\Rightarrow$ \ref{SetProof2})"', "`\ref{SetProof2})
$\Rightarrow$ \ref{SetProof3})"' und "`\ref{SetProof3})
$\Rightarrow$ \ref{SetProof1})"' gebildet, was die Äquivalenz der
Aussagen zeigt.\qed
\end{proof}

\special{pdf: out 3 << /Title 
(Widerspruchsbeweise)
/Dest [ @thispage /FitH @ypos ] >>}
\subsection{Widerspruchsbeweise}
\label{IndirektBeweis}
Obwohl die Technik der
Widerspruchsbeweise\index{Widerspruchsbeweis}\index{Beweis!Widerspruch}
auf den ersten Blick sehr kompliziert erscheint, ist sie meist einfach
anzuwenden, extrem mächtig und liefert oft sehr kurze
Beweise. Angenommen wir sollen die Richtigkeit einer Aussage "`aus der
Hypothese $H$ folgt $C$"' zeigen. Dazu beweisen wir, dass sich ein
Widerspruch ergibt, wenn wir, von $H$ und der Annahme, dass $C$ falsch
ist, ausgehen. Also war die Annahme falsch, und die Aussage $C$ muss
richtig sein.

Anschaulicher wird diese Beweistechnik durch folgendes Beispiel:
Nehmen wir einmal an, dass Alice eine bürgerliche Frau ist und deshalb
auch keine Krone trägt. Es ist klar, dass jede Königin eine Krone
trägt. Wir sollen nun beweisen, dass Alice keine Königin ist. Dazu
nehmen wir an, dass Alice eine Königin ist, d.h.~Alice trägt eine
Krone. Dies ist ein Widerspruch! Also war unsere Annahme falsch, und
wir haben gezeigt, dass Alice keine Königin sein kann.

\goodbreak
\noindent Der Beweis zu folgendem Satz verwendet diese Technik:
\begin{theorem}
Sei $S$ eine endliche Untermenge einer unendlichen Menge $U$. Sei $T$
das Komplement von $S$ bzgl.~$U$, dann ist $T$ eine unendliche Menge.
\end{theorem}

\begin{proof}
Hier ist unsere Hypothese "`$S$ endlich, $U$ unendlich und $T$
Komplement von $S$ bzgl.~$U$"' und unsere Folgerung ist "`$T$ ist
unendlich"'. Wir nehmen also an, dass $T$ eine endliche Menge ist. Da
$T$ das Komplement von $S$ ist, gilt $S \cap T = \emptyset$, also ist
$\cnt(S) + \cnt(T) = \cnt (S \cap T) + \cnt (S \cup T) = \cnt (S \cup
T) = n$, wobei $n$ eine Zahl aus $\N$ ist (siehe
Abschnitt \ref{cntSet}). Damit ist $S \cup T = U$ eine endliche
Menge. Dies ist ein Widerspruch zu unserer Hypothese! Also war die
Annahme "`$T$ ist endlich"' falsch. \qed
\end{proof}

\special{pdf: out 3 << /Title 
(Der Schubfachschluss)
/Dest [ @thispage /FitH @ypos ] >>}
\subsection{Der Schubfachschluss}
\label{Schubfachschluss}
Der \dindex{Schubfachschluss} ist auch als \dindex{Dirichlets
Taubenschlagprinzip}\index{Taubenschlagprinzip} bekannt.  Werden $n >
k$ Tauben auf $k$ Boxen verteilt, so gibt es mindestens eine Box in
der sich wenigstens zwei Tauben aufhalten. Allgemeiner formuliert sagt
das Taubenschlagprinzip, dass wenn $n$ Objekte auf $k$ Behälter
aufgeteilt werden, dann gibt es mindestens eine Box die mindestens
$\lceil \frac{n}{k} \rceil$ Objekte enthält.

\begin{example}
Auf einer Party unterhalten sich $8$ Personen ($\triangleq$ Objekte),
dann gibt es mindestens einen Wochentag ($\triangleq$ Box) an dem
$\lceil \frac{8}{7} \rceil =2$ Personen aus dieser Gruppe Geburtstag
haben.
\end{example}

\special{pdf: out 3 << /Title 
(Gegenbeispiele)
/Dest [ @thispage /FitH @ypos ] >>}
\subsection{Gegenbeispiele}
Im wirklichen Leben wissen wir nicht, ob eine Aussage richtig oder
falsch ist. Oft sind wir dann mit einer Aussage konfrontiert, die auf
den ersten Blick richtig ist und sollen dazu ein Programm
entwickeln. Wir müssen also entscheiden, ob diese Aussage wirklich
richtig ist, denn sonst ist evtl.~alle Arbeit umsonst und hat hohen
Aufwand verursacht. In solchen Fällen kann man versuchen, ein einziges
Beispiel dafür zu finden, dass die Aussage falsch ist, um so unnötige
Arbeit zu sparen.\index{Gegenbeispiel}

\bigskip

\noindent Wir zeigen, dass die folgenden Vermutungen falsch sind:
\begin{conjecture}
Wenn $p \in \N$ eine Primzahl ist, dann ist $p$ ungerade.
\end{conjecture}

\begin{counterexample}
Die natürliche Zahl 2 ist eine Primzahl und $2$ ist gerade. \qed
\end{counterexample}

\begin{conjecture}
Es gibt keine Zahlen $a,b \in \N$, sodass $a \textrm{ mod } b = b
\textrm{ mod } a$.
\end{conjecture}

\begin{counterexample}
Für $a = b = 2$ gilt $a \textrm{ mod } b = b \textrm{ mod } a = 0$. \qed
\end{counterexample}

\special{pdf: out 3 << /Title 
(Induktionsbeweise und das Induktionsprinzip)
/Dest [ @thispage /FitH @ypos ] >>}
\subsection{Induktionsbeweise und das Induktionsprinzip}
Eine der wichtigsten und nützlichsten Beweismethoden in der Informatik bzw.~Mathematik
ist das \dindex{Induktionsprinzip}. Wir wollen jetzt nachweisen, dass
für jedes $n \in \N$ eine bestimmte Eigenschaft $E$ gilt. Wir
schreiben kurz $E(n)$ für die Aussage "`$n$ besitzt die Eigenschaft
$E$"'. Mit der Schreibweise $E(0)$ drücken\footnote{Mit $E$ wird also
ein Prädikat bezeichnet (siehe Abschnitt \ref{MengenDef})} wir also
aus, dass die erste natürliche Zahl $0$ die Eigenschaft $E$ besitzt.

\noindent\textbf{Induktionsprinzip:} Es gelten
\index{Induktion!Prinzip}
\indudef%
{$E(0)$}% 
{Für $n \ge 0$ gilt, wenn $E(k)$ für $k \le n$ korrekt ist,
dann ist auch $E(n+1)$ richtig.}
\medskip

Dabei ist \textbf{\textsf{IA}} die Abkürzung für
\dindex{Induktionsanfang} und \textbf{\textsf{IS}} ist die Kurzform von
\dindex{Induktionsschritt}. Die Voraussetzung ($\triangleq$ Hypothese)
$E(k)$ ist korrekt für $k \le n$ und wird im Induktionsschritt
als \dindex{Induktionsvoraussetzung} benutzt
(kurz \textbf{\textsf{IV}}). Hat man also den Induktionsanfang und den
Induktionsschritt gezeigt, dann ist es anschaulich, dass jede natürliche Zahl die
Eigenschaft $E$ haben muss.

Es gibt verschiedene Versionen von Induktionsbeweisen. Die bekannteste
Version ist die vollständige Induktion, bei der Aussagen über
natürliche Zahlen gezeigt werden.

\special{pdf: out 4 << /Title 
(Die vollständige Induktion)
/Dest [ @thispage /FitH @ypos ] >>}
\subsubsection{Die vollständige Induktion}

Wie in Piratenfilmen üblich, seien Kanonenkugeln in einer Pyramide mit
quadratischer Grundfläche gestapelt. Wir stellen uns die Frage,
wieviele Kugeln (in Abhängigkeit von der Höhe) in einer solchen
Pyramide gestapelt sind.\index{vollständige Induktion}\index{Induktion!vollständige}

\begin{theorem}
\label{Pyramid}
Mit einer quadratische Pyramide aus Kanonenkugeln der Höhe $n \ge 1$
als Munition, können wir $\frac{n(n+1)(2n+1)}{6}$ Schüsse abgeben.
\end{theorem}

\goodbreak
\begin{proof}
Einfacher formuliert: wir sollen zeigen, dass $\sum\limits_{i=1}^n i^2 =
\frac{n(n+1)(2n+1)}{6}$.
\induproof%
{Eine Pyramide der Höhe $n = 1$ enthält $\frac{1 \cdot 2 \cdot 3}{6} =
  1$ Kugel. D.h.~wir haben die Eigenschaft für $n = 1$ verifiziert.}%
{Für $k \le n$ gilt $\sum\limits_{i=1}^k i^2 = \frac{k(k+1)(2k+1)}{6}$.}%
{%
Wir müssen nun zeigen, dass $\sum\limits_{i=1}^{n+1} i^2 =
\frac{(n+1)((n+1)+1)(2(n+1)+1)}{6}$ gilt und dabei muss die
Induktionsvoraussetzung $\sum\limits_{i=1}^n i^2 = \frac{n(n+1)(2n+1)}{6}$
benutzt werden.  

\begin{displaymath}
\begin{array}{rcl}
\sum\limits_{i=1}^{n+1}i^2 &=& \sum\limits_{i=1}^{n}i^2 + (n + 1)^2\\
&\stackrel{\text{\textbf{\textsf{IV}}}}{=}& \frac{n(n+1)(2n+1)}{6} +
(n^2 + 2n + 1)\\
&=& \frac{2n^3 + 3n^2+n}{6} + (n^2 + 2n + 1)\\
&=& \frac{2n^3 + 9n^2+13n + 6}{6}\\
&=& \frac{(n+1)(2n^2+7n+6)}{6} \quad (\star)\\
&=& \frac{(n+1)(n+2)(2n+3)}{6} \quad (\star\star)\\
&=& \frac{(n+1)((n+1) + 1)(2(n + 1) + 1)}{6}\\
\end{array}
\end{displaymath}
Die Zeile $\star$ (bzw.~$\star\star$) ergibt sich, indem man $2n^3 +
9n^2+13n + 6$ durch $n+1$ teilt (bzw.~$2n^2+7n+6$ durch $n+2$). \qed
}
\end{proof}

Das Induktionsprinzip kann man auch variieren. Dazu soll nun gezeigt
werden, dass die Eigenschaft $E$ für alle Zahlen $k \le n$ erfüllt
ist.

\noindent\textbf{Verallgemeinertes Induktionsprinzip:} Es gelten 
\index{Induktion!Prinzip!verallgemeinert}
\indudef%
{$E(0)$}% 
{Wenn für alle $0 \le k \le n$ die Eigenschaft $E(k)$ gilt, dann ist 
auch $E(n+1)$ richtig.}
\medskip

Damit ist das verallgemeinerte Induktionsprinzip eine
Verallgemeinerung des oben vorgestellten Induktionsprinzips, wie das
folgende Beispiel veranschaulicht:

\begin{theorem}
Jede natürliche Zahl $n \ge 2$ läßt sich als Produkt von Primzahlen 
schreiben.
\end{theorem}
\begin{proof}
Das verallgemeinerte Induktionsprinzip wird wie folgt verwendet:
\induproof{%
Offensichtlich ist $2$ das Produkt von einer Primzahl.
}{%
Jede natürliche Zahl $m$ mit $2 \le m \le n$ kann als Produkt von
Primzahlen geschrieben werden.
}{
Nun wird eine Fallunterscheidung durchgeführt:
\begin{enumerate}[i)]
%
\item Sei $n+1$ wieder eine Primzahl, dann ist nichts zu zeigen, da
$n+1$ direkt ein Produkt von Primzahlen ist. 
%
\item Sei $n+1$ keine Primzahl, dann existieren mindestens zwei Zahlen
$p$ und $q$ mit $2 \le p,q < n+1$ und $p \cdot q = n + 1$. Nach
Induktionsvoraussetzung sind dann $p$ und $q$ wieder als Produkt von
Primzahlen darstellbar. Etwa $p = p_1 \cdot p_2 \cdot \ldots \cdot p_s$
und $q = q_1 \cdot q_2 \cdot \ldots \cdot q_t$. Damit ist aber $n + 1 =
p \cdot q = p_1 \cdot p_2 \cdot \ldots \cdot p_s \cdot q_1 \cdot
q_2 \cdot \ldots \cdot q_t$ ein Produkt von Primzahlen.\qed
}
%
\end{enumerate}

\end{proof}


\noindent Solche Induktionsbeweise treten z.B.~bei der Analyse von Programmen
immer wieder auf.

\special{pdf: out 4 << /Title 
(Induktive Definitionen)
/Dest [ @thispage /FitH @ypos ] >>}
\subsubsection{Induktive Definitionen}

Das Induktionsprinzip kann aber auch dazu verwendet werden,
(Daten-)Strukturen formal zu spezifizieren. Dazu werden in einem
ersten Schritt ($\triangleq$ Induktionsanfang) die "`atomaren"'
Objekte definiert und dann in einem zweiten Schritt die
zusammengesetzten Objekte ($\triangleq$ Induktionsschritt). Diese
Technik ist als \dindex{induktive Definition} bekannt.

\begin{example}
\noindent Ein Baum ist wie folgt definiert:

\medskip

\indudef{Ein einzelner Knoten $w$ ist ein \emph{Baum} und $w$ ist die
  \emph{Wurzel} dieses Baums.}{Seien $T_1, T_2, \dots, T_n$ Bäume mit den
  Wurzeln $\enu{k}{1}{n}$ und $w$ ein einzelner neuer Knoten. Verbinden wir
  den Knoten $w$ mit allen Wurzeln $\enu{k}{1}{n}$, dann entsteht ein neuer Baum
  mit der Wurzel $w$.} 
\end{example}

\begin{example}
\label{induexp}
\noindent Ein arithmetischer Ausdruck ist wie folgt definiert:

\medskip

\indudef{Jeder Buchstabe und jede Zahl ist ein arithmetischer
Ausdruck.}{Seien $E$ und $F$ Ausdrücke, so sind auch $E + F$, $E * F$
und $[E]$ Ausdrücke.}

\medskip

\noindent D.h.~$x$, $x+y$, $[2*x + z]$ sind arithmetische Ausdrücke,
aber beispielsweise sind $x + $, $yy$, $][x+y$ sowie $x +* z$ keine
Ausdrücke im Sinn dieser Definition.
\end{example}

Bei diesem Beispiel ahnt man schon, dass solche Techniken zur präzisen
Definition von Programmiersprachen und Dateiformaten gute Dienste
leisten. Induktive Definitionen haben noch einen weiteren Vorteil,
denn man kann leicht Induktionsbeweise konstruieren, die Aussagen über
induktiv definierte Objekte belegen.

\special{pdf: out 4 << /Title 
(Die strukturelle Induktion)
/Dest [ @thispage /FitH @ypos ] >>}
\subsubsection{Die strukturelle Induktion}

\begin{theorem}
\label{CntBrack}
Die Anzahl der öffnenden Klammern eines arithmetischen Ausdrucks stimmt
mit der Anzahl der schließenden Klammern überein.
\end{theorem}

Es ist offensichtlich, dass diese Aussage richtig ist, denn in
Ausdrücken wie $(x + y) / 2$ oder $x + ((y/2) * z)$ muss ja zu jeder
öffnenden Klammer eine schließende Klammer existieren. Der nächste
Beweis verwendet diese Idee zum die Aussage von Satz \ref{CntBrack}
mit Hilfe einer \dindex{strukturellen Induktion}\index{Induktion!strukturelle} 
zu zeigen.

\begin{proof}
Wir bezeichnen die Anzahl der öffnenden Klammern eines Ausdrucks $E$
mit $\cnt_[(E)$ und verwenden die analoge Notation $\cnt_](E)$ für die
Anzahl der schließenden Klammern.

\induproof%
{
Die einfachsten Ausdrücke sind Buchstaben und Zahlen. Die Anzahl der
öffnenden und schließenden Klammern ist in beiden Fällen gleich $0$.
}
{
Sei $E$ ein Ausdruck, dann gilt $\cnt_[(E) = \cnt_](E)$.
}
{
 Für einen Ausdruck $E + F$ gilt $\cnt_[(E + F) = \cnt_[(E
) +
 \cnt_[(F) \stackrel{\text{\textbf{\textsf{IV}}}}{=} \cnt_](E) +
 \cnt_](F) = \cnt_](E + F)$. Völlig analog zeigt man dies für $E *
 F$. Für den Ausdruck $[E]$ ergibt sich $\cnt_[([E]) = \cnt_[(E) + 1
 \stackrel{\text{\textbf{\textsf{IV}}}}{=} \cnt_](E) + 1 = \cnt_]([E])$.
 In jedem Fall ist die Anzahl der öffnenden Klammern gleich der Anzahl
 der schließenden Klammern.\qed
}
\end{proof}

\bigskip

Mit Hilfe von Satz \ref{CntBrack} können wir nun leicht ein Programm
entwickeln, das einen Plausibilitätscheck (z.B.~direkt in einem Editor)
durchführt und die Klammern zählt, bevor die Syntax von arithmetischen
Ausdrücken überprüft wird. Definiert man eine vollständige
Programmiersprache induktiv, dann werden ganz ähnliche
Induktionsbeweise möglich, d.h.~man kann die Techniken aus diesem
Beispiel relativ leicht auf die Praxis der Informatik übertragen.
