\section{Basic Functional Programming in Coq}




\subsection{Introduction}

In this chapter we are going to introduce the most essential elements of Coq's functional programming language called {\itshape  Gallina}. 
Moreover, {\itshape tactics}, which can be applied to prove properties of Coq programs, are introduced.


\subsection{Data and Functions}

 \paragraph{Enumerated Type}
 
  The built-in features set in Coq is extremely small. In particular, Coq is a powerful mechanism for defining data types from scratch.
  Current Coq distributions come preloaded with an extensive standard library.
  Bools, numbers, data struts like lists and hash tables.\\
  In this course we are going to explicitly recapitulate the used definitions.
   
  
  \begin{example}
  We are defining a type called \lstinline!day!.
  \begin{lstlisting}
    Inductive day: Type :=
	  | monday
	  | tuesday
	  | wednesday
	  | thursday
	  | friday.
	  | saturday.
	  | sunday.
	  \end{lstlisting} 
  
  The type members are called \lstinline!monday!, \lstinline!tuesday! , \lstinline!wednesday! \ldots{} and \lstinline!sunday!.\\
  
  We are defining a function operating on \lstinline!day!: 
  \begin{lstlisting}
  Definition next_weekday(d:day) day:=
    match d with 
	  | monday => tuesday
	  | tuesday => wednesday
	  | wednesday => thursday
	  | thursday => friday
	  | friday => monday
	  | saturday => monday
	  | sunday => monday.
    end.  
  \end{lstlisting}
  \end{example}

  Coq is able of {\itshape type  interference}, whenever the type is not defined explicitly.
  But for readability, we are including types in the following.
   
  For testing the above definition and function we have three possibilities in Coq:
     
   \begin{enumerate}
   \item Compute a compound expression including the function:\\
 		 \lstinline! compute (next_weekday friday).  (* = monday : day *)! or \\
   		 \lstinline! compute (next_weekday (next_weekday saturday)). (* = tuesday : day *)!
   \item Record an expected behaviour as a Coq-\lstinline!Example! and verify the assertion: 
         E.g.: {\itshape The second weekday after Saturday is Tuesday.}  
   
		   \begin{lstlisting}
		   		Example. test_next_weekday: (next_weekday (next_weeekday(saturday)) = tuesday 
		   		proof. simpl. reflexivity. Qed.
		   \end{lstlisting}
   			The details of the implementation are not important right now. We are going to come back to them later.
   \end{enumerate}   

    Moreover, Coq can be asked to \lstinline!extract! a program from our \lstinline! Definition! in a programming language, which is more conventional, being equipped with a high performance compiler.
    In particular this is one of the main uses of Coq. 
    It provides a method to transfer proved-correct algorithms in Gallina to efficient machine code.
    (Assuming the correctness of the corresponding high performance compile e.g. the Ocaml, Haskell or Scheme compiler. 


\subsection{Booleans}

    Of course, Coq provides an default implementation of booleans.
    (See the \href{https://www.cs.princeton.edu/courses/archive/fall07/cos595/stdlib/html/Coq.Init.Datatypes.html}{Coq.Init.Datatypes in the Coq-Library documentation}).  
    In the following we are going to be consistent with the Coq library documentation according to the standard library.
    We are going to introduce coinciding selfdefined data types whenever possible.
    Booleans can be defined as follows:
    
    \label{Def:booleans}
    \begin{lstlisting}    
    Inductive bool: Type :=
      | true
      | false.
    \end{lstlisting}
    
    A function with multiple input arguments is implemented by
    \begin{lstlisting}
    Definition orb (b1: bool) (b2: bool) : bool :=
    match b1 with
	  | true -> true
	  | false -> b2
    end.
    \end{lstlisting}
    
    The functions \lstinline!negb! and \lstinline!andb! corresponding to the boolean functions {\emph negation} and {\emph and} are implemented in a similar manner.
     
    And a new symbolic notations is implemented as follows
    \begin{lstlisting}
    Notation "x && y" := (andb x y).
    Notation "x||y" := (orb x y).
    \end{lstlisting}
    
     
\subsection{Notation}
    As in the Coq doc documentation tool the following notation convention is introduced:
     
    \begin{enumerate}
     \item In \texttt{.v-files} comments are annotated by \lstinline!(* some comment *)!. 
     \item Within these comments Coq-code is denoted by \lstinline![example].! 
     \item And we write \lstinline! Admitted.! at the end of an incomplete proof.    
     \end{enumerate}
     
     
\subsection{Types}
     Every expression in Coq has a type.
     \begin{enumerate}
      \item  \lstinline* Check true.* gives the type of the expression \lstinline! boolean!.
      \item \lstinline! Check negb.! returns \lstinline! bool -> bool! . (Read as  ``bool arrow bool'').
           %  It is the functions input data type and the output data type, given input data of that type.
       \item \lstinline! andb! returns \lstinline!bool->bool->bool!. This function produces an output of type \lstinline! bool! given two inputs of type \lstinline! bool!.
     \end{enumerate}
   
\subsection{New Types from Old}
     
     
	 Note that so far the data-types we have seen were enumerated types.
	 Let's define a data type \lstinline!rgb! and a data type, whose constructor takes this type as an argument.
	\begin{lstlisting}
	 Inductive rgb: Type:=
	  | red     (* These are *)
	  | green   (* the expressions *)
	  | blue.   (* in the set [rgb]. *)
	 \end{lstlisting}
	 The constructors of the type \lstinline!rgb! are \lstinline!red, green! and \lstinline!blue!. 
	 
	 \begin{lstlisting}
	 Inductive color: Type := 
	  | black
	  | white
	  | primary (p:rgb). (* If [p] is in the set [rgb], then the constructor [primary] applied to the argument [p] is an expression in the set color.*) 
	 \end{lstlisting}
	 
	 The expressions in the set color are \lstinline!black, white! and \lstinline!primary!.
	 Note that, expressions formed as above are the only ones belonging to the sets \lstinline!rgb! and \lstinline!color!.
	 

\subsection{Tuples}

    A single constructor with multiple parameters can be used to create a type \lstinline! tuple!.
	\begin{example}[A nybble: half a byte]
 	 	\begin{lstlisting}
 	 		Inductive bit: Type := (*a bit*) 
 	 		 |B0
 	 		 |B1.
 		    Inductive nybble: Type := (*a nybble*)
 		   	 |bits( b0 b1 b2 b3: bit).
 		   			 	
 		   	Check(bits B1 B0 B1 B0) (* => bits B1 B0 B1 B0 : nybble *)
 		\end{lstlisting}
 		Hence, a tuple of four bits is a nybble.
 		
 		Assume we would like to test a nybble in order to see if all its bits are 0. We are unwrapping the nybble by patternmatching:
 		\begin{lstlisting}
 		Definition all_zero(nb: nybble): bool :=
 		  match nb with
 	  	    |(bits B0 B0 B0 B0) -> true
 		    |(bits _ _ _ _) -> false (* This wildcard pattern was included to avoid inventing variable names, which are not going to be used. *) 
 		  end.
 		 \end{lstlisting}
 	\end{example}
 	

\subsection{Modules}

	Coq provides a {\itshape module system} to aid organizing large developments.
	In this course most of it is not going to be needed.

	\begin{lstlisting}
	Module X 
	...
	End X
	\end{lstlisting}

\subsection{Numbers}

  Note that on the one hand the types day, bool, bits and tuples have a finite set of values, while on the other hand the set of natural numbers $\mathbb{N}$ is an infinite set.
 
  Hence, we have to construct $\mathbb{N}$ using a data type with a final number of constructors. 
  Recall, many representations of $\mathbb{N}$ exits (e.g. hexadecimal with base 16, octa with base 8, binary with base 2).
  The most familiar is the decimal representation.\\
  However, each representation of $\mathbb{N}$ is useful under different circumstances. 
  The binary representation is valuable in computer hardware, because it presents a simple circuitry.
  Here we are aiming to make proofs simple using the unary (base 1) representation.
  
  \begin{lstlisting}
  Module NatPlayground
  Inductive nat: Type :=
    | 0
    | S (n:nat).
  \end{lstlisting}
  
  One might picture this representation by scratches on a wall in prison. \\
  It uses two constructors: 
  \begin{itemize}
  \item The letter \lstinline!0! represents the natural number zero. 
  \item The letter \lstinline!S! represents a natural number $n\in\mathbb{N}\setminus\{ 0\}$.  
  \end{itemize}
  There is a way of converting this representation refereed to as \lstinline!nat! into its decimal representation. This is elaborated as follows.
  \begin{example}
  
	  \begin{tabular} {r l}
	  
		  \texttt{unitary}				& \texttt{decimal}	\\
		  \texttt{\lstinline!0!} 		&: 0 				\\
		  \texttt{\lstinline! S 0!}  	&: 1				\\
		  \texttt{\lstinline! S ( S 0)!}	&: 2				\\
		  \texttt{\lstinline! S( S ( S 0))!}	&: 3				\\
		    
	  \end{tabular}
  \end{example}
  Moreover, it is easy to see that 
  \begin{itemize}
  \item \lstinline! 0! belongs to the set \lstinline! nat!
  \item  If \lstinline! n ! is in the set \lstinline! nat!, it follows \lstinline! S n ! is an expression belonging to the set \lstinline! nat !.
  \item And expressions belong the set \lstinline! nat! if and only if they are  formed by either of those methods (i.e. \lstinline! 0 ! or  \lstinline! S n!). 
  \end{itemize}
  
  
  Note that the same results apply to the definitions of \lstinline! day!, \lstinline! bool! and \lstinline! color!.
  These conditions are a precise force of the \lstinline! Inductive! declaration. Expressions like \lstinline!true!. \lstinline! false!, \lstinline! S( false( 0 ( 0 S )))! do not belong to this set.  
  But on the other hand \lstinline! 0! and \lstinline! S! are arbitrary symbols chosen in the defined representation. The interpretation of these marks is given by their usage in computing.
  To realize this functions, which ``pattern match'' a represnation of natural numbers are written.
  
  We are following the idea:  If n has the form \lstinline! Sn'! for some \lstinline! n'!, then return  \lstinline! n'!.
  \begin{example}[predecessor function]
   \begin{lstlisting}
   Definition pred (n:nat): nat :=
   	match n with 
   	  | 0 => 0
   	  | S n' => n'
   	  end.
   	  
   	  Check 
   	  
   	  End NatPlayground
   	  check( S(S(S(S(0)))). (* = 4: nat *)
   \end{lstlisting}
  \end{example}
  Because natural numbers are such a pervasive form of data, Coq always prints out a natural number. ( It uses a `` bulid-in magic'' for paring and printing.)
 
  \begin{lstlisting}
  Definition minustwo( n: nat) : nat :=
    match n with
      | 0 => 0
      | S 0 => 0
      | S ( S n') = > n'
     end.
     
     compute( minustwo(4)) (* = 2: nat *)
  \end{lstlisting}  