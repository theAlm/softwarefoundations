\section{Basic Functional Programming in Coq}




\subsection{Introduction}

In this chapter we are going to introduce the most essential elemets of Coq's functional programming language called {\itshape  Gallina}. 
Moreover, {\itshape tactics}, that can be applied to prove properties of Coq programs are introduced.


\subsection{Data and Functions}

 \paragraph{Enumerated Type}
 
  The built-in features set is extremely small in Coq. It is a powerful mechanism for defining data types from scratch.
  Current Coq distributions are preloaded with an extensive standard library.
  Boolean numbers may come data structure lists and hash readable. 
  
  \begin{example}
  We are defining a type 
  \begin{lstlisting}
    Inductive day: Type :=
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday.
  | saturday.
  | sunday.
  \end{lstlisting} 
  And a function on it: 
  \begin{lstlisting}
  Definition next_weekday(d:day) day:=
  match d with 
	  monday -> tuesday
	  tuesday -> wednesday
	  wednesday -> thursday
	  thursday -> friday
	  friday -> monday
	  saturday -> monday
	  sunday -> sunday.
  end.  
  \end{lstlisting}
  \end{example}

  Coq can do type interference if the type is not defined explicitly.
  But for readability, we include types in the following.
   
  For testing the above definition and function we have three possibilities:   
   \begin{enumerate}
   \item compute a compound compressions including the function:\\
   \lstinline! compute (next_weekday friday).! or 
   \lstinline! compute (next_weekday (next_weekday saturday)).!
   \item record an expected bahavior: \lstinline! test_next_weekday:(next_weekday (next_weekday saturday)).! 
   \item make an assertion: {\itshape The second weekday after Saturday is Tuesday.} And verify the assertion. 
   \begin{lstlisting}
   		Example. test_next_weekday: (next_weekday (next_weeekday(saturday)) = tuesday 
   		proof. simpl. reflexivity. Qed.
   \end{lstlisting}
   \end{enumerate}   

    Moreover, Coq can be asked to \lstinline!extract! a program in a programming language, which is more conventional, being equipped with a high performance compiler.
    In particular this is one of the main uses of Coq. 
    It provides a method to transfer correct proven algorithms in Gallina to efficient machine code.
    (Assuming the correctness of the corresponding high performance compile e.g.the Ocaml, Haskell or Scheme compiler. 


\subsection{Booleans}

    Of course, Coq provides an default implementation of booleans. (See the \href{https://www.cs.princeton.edu/courses/archive/fall07/cos595/stdlib/html/Coq.Init.Datatypes.html}{Coq.Init.Datatypes Library}). %TODO: add link.
    In the following we are going to be consistent with the Coq library documentation according to the standart library. We are going to introduce coinciding selfdefined datatypes.
    Booleans can be defined as follows:
    
    \label{Def:booleans}
    \begin{lstlisting}    
    Inductive bool: Type :=
    | true
    | false.
    \end{lstlisting}
    
    A function with multiple input argumens is implemented as in the following:
    \begin{lstlisting}
    Definition orb (b1: bool) (b2: bool) : bool :=
    match b1 with
    | true -> true
    | false -> b2
    end.
    \end{lstlisting}
     
    And its new symbolic notation like this:
    \begin{lstlisting}
    Notation "x && y" := (andb x y).
    Notation "x||y" := (orb x y).
    \end{lstlisting}
    
     
\subsection{Notation}
     
    \begin{enumerate}
     \item In \texttt{.v-files} comments are annotated by \lstinline!(* some comment *)!. 
     \item Within these comments Coq-cod is denoted by \lstinline![example].! 
     \item And we write \lstinline! Admitted.! at the end of an incomplete proof.    
     \end{enumerate}
     
     
\subsection{Types}

     Every expression has a type.
     \begin{enumerate}
     \item  \lstinline! Check true.! gives the type of the method \lstinline! boolean!.
     \item \lstinline! Check negb.! returns \lstinline! bool -> bool!( read \glqq bool arrow bool\grqq).
      It is the functions input data type and the output data type, given input data of that type.
      \item \lstinline! andb! returns \lstinline!bool->bool->bool!. This function produces an output of type bool given two bools.
     \end{enumerate}
     
\subsection{New Types from Old}
	
	Consturctor takes an argument.
	\begin{lstlisting}
	 Inductive rgb: Type:=
	 | red 
	 | green
	 | blue.
	 
	 Inductive color: Type := 
	 | black
	 | white
	 | primary (p:rgb).
	 
	 \end{lstlisting}
	 
     
     
     