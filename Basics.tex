

TODO: Explain what Gallina is.


\section{Basic Functional Programming in Coq}

\subsection{Data and Functions}
 \paragraph{Enumerated Type}
  The built-in features set is extremely small in Coq. It is a powerful mechanism for defining data types from scratch.
  Current Coq distributions are preloaded with an extensive standard library.
  Boolean numbers may come data structure lists and hash readable. 
  
  \begin{example}
  We are defining a type 
  \begin{lstlisting}
    Inductive day: Type :=
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday.
  | saturday.
  | sunday.
  \end{lstlisting} 
  And a function on it: 
  \begin{lstlisting}
  Definition next_weekday(d:day) day:=
  match d with 
	  monday -> tuesday
	  tuesday -> wednesday
	  wednesday -> thursday
	  thursday -> friday
	  friday -> monday
	  saturday -> monday
	  sunday -> sunday.
  end.  
  \end{lstlisting}
  \end{example}

  Coq can do type interference when the type is not defined explicitly.
  But for readability, we include types in the following.
   
  For testing the above definition and function we have three possibilities:
   
%   \begin{enumerate}
%   \item compute a compound compressions including the function:\\
%   \lstinline! compute (next_weekday friday).! or 
%   \lstinline! compute (next_weekday (next_weekday saturday)).!
%   \item record anit: \lstinline! test_next_weekday:(next_weekday (next_weekday saturday)).! 
%   \item make an assertion: The second weekday after Saturday is Tuesday. And verify the assertion. 
%   \begin{lstlisting}
%   		Example. test_next_weekday: (next_weekday (next_weeekday(saturday)) = tuesday 
%   		proof. simpl. reflexivity. Qed.
%   \end{lstlisting}
%   \end{enumerate}   

    Moreover, Coq can be asked to \lstlisting!extract! a program in a programming language, which is more conventional being equipped with a high performance compiler.
    In particular this is one of the main uses of Coq. 
    It provides a method to transfer correct proven algorithms in Gallina to efficient machine code.
    (Assuming the correctness of the $\delta$caml/ Haskell/ Scheme Compliler). %TODO: rewrite this sentence
    
    \subsection{Booleans}
    Of course, Coq provides an default implementation of booleans. (See the Coq.Init.Datatypes). %TODO: add link.
    In the following we are going to be consistent with the Coq library documentation according the standart library. We are going to introduce coinciding selfdefined datatypes.
    Booleans can be defined as follows:
    
    \label{Def:booleans}
    \begin{lstlisting}    
    Inductive bool: Type :=
    | true
    | false.
    \end{lstlisting}
    
    A function with multiple input argumens is implemented as in the following:
    \begin{lstlisting}
    Definition orb (b1: bool) (b2: bool) : bool :=
    match b1 with
    | true -> true
    | false -> b2
    end.
    \end{lstlisting}
     
    And its new symbolic notation like this:
    \begin{lstlisting}
    Notation "x && y" := (andb x y).
    Notation "x||y" := (orb x y).
    \end{lstlisting}
     
     \subsection{Notation}
    \begin{enumerate}
     \item In \texttt{.v-files} comments are annotated by \lstinline!(* some comment *)!. 
     \item Within these comments Coq-cod is denoted by \lstinline![ Exmaple].! 
     \item And we write \lstinline! Admitted.! at the end of an incomplete proof.    
     \end{enumerate}
     
     \subsection{Types}
     Every expression has a type.
     \begin{enumerate}
     \item  \lstinline! Check true.! Gives the type of the method \lstinline! boolean!.
     \item \lstinline! Check negb.!. returns \lstinline! bool -> bool" !( read \glqq bool arrow bool\grqq).
      It is the functions input data type and the output data type given input data of that type.
      \item \lstinline! andb! returns \lstinline!bool->bool->bool! this function produces an output of type bool given two bools.
     \end{enumerate}
     
     
     