\section{Basic Functional Programming in Coq}




\subsection{Introduction}

In this chapter we are going to introduce the most essential elements of Coq's functional programming language called {\itshape  Gallina}. 
Moreover, {\itshape tactics}, which can be applied to prove properties of Coq programs, are introduced.


\subsection{Data and Functions}

 \paragraph{Enumerated Type}
 
  The built-in features set in Coq is extremely small. In particular, Coq is a powerful mechanism for defining data types from scratch.
  Current Coq distributions come preloaded with an extensive standard library.
  Bools, numbers, data struts like lists and hash tables.\\
  In this course we are going to explicitly recapitulate the used definitions.
   
  
  \begin{example}
  We are defining a type called \lstinline!day!.
  \begin{lstlisting}
    Inductive day: Type :=
	  | monday
	  | tuesday
	  | wednesday
	  | thursday
	  | friday.
	  | saturday.
	  | sunday.
	  \end{lstlisting} 
  
  The type members are called \lstinline!monday!, \lstinline!tuesday! , \lstinline!wednesday! \ldots{} and \lstinline!sunday!.\\
  
  We are defining a function operating on \lstinline!day!: 
  \begin{lstlisting}
  Definition next_weekday(d:day) day:=
    match d with 
	  | monday => tuesday
	  | tuesday => wednesday
	  | wednesday => thursday
	  | thursday => friday
	  | friday => monday
	  | saturday => monday
	  | sunday => monday.
    end.  
  \end{lstlisting}
  \end{example}

  Coq is able of {\itshape type  interference}, whenever the type is not defined explicitly.
  But for readability, we are including types in the following.
   
  For testing the above definition and function we have three possibilities in Coq:
     
   \begin{enumerate}
   \item Compute a compound expression including the function:\\
 		 \lstinline! compute (next_weekday friday).  (* = monday : day *)! or \\
   		 \lstinline! compute (next_weekday (next_weekday saturday)). (* = tuesday : day *)!
   \item Record an expected behaviour as a Coq-\lstinline!Example! and verify the assertion: 
         E.g.: {\itshape The second weekday after Saturday is Tuesday.}  
   
		   \begin{lstlisting}
		   		Example. test_next_weekday: (next_weekday (next_weeekday(saturday)) = tuesday 
		   		proof. simpl. reflexivity. Qed.
		   \end{lstlisting}
   			The details of the implementation are not important right now. We are going to come back to them later.
   \end{enumerate}   

    Moreover, Coq can be asked to \lstinline!extract! a program from our \lstinline! Definition! in a programming language, which is more conventional, being equipped with a high performance compiler.
    In particular this is one of the main uses of Coq. 
    It provides a method to transfer proved-correct algorithms in Gallina to efficient machine code.
    (Assuming the correctness of the corresponding high performance compile e.g. the Ocaml, Haskell or Scheme compiler. 


\subsection{Booleans}

    Of course, Coq provides an default implementation of booleans.
    (See the \href{https://www.cs.princeton.edu/courses/archive/fall07/cos595/stdlib/html/Coq.Init.Datatypes.html}{Coq.Init.Datatypes in the Coq-Library documentation}).  
    In the following we are going to be consistent with the Coq library documentation according to the standard library.
    We are going to introduce coinciding selfdefined data types whenever possible.
    Booleans can be defined as follows:
    
    \label{Def:booleans}
    \begin{lstlisting}    
    Inductive bool: Type :=
      | true
      | false.
    \end{lstlisting}
    
    A function with multiple input arguments is implemented by
    \begin{lstlisting}
    Definition orb (b1: bool) (b2: bool) : bool :=
    match b1 with
	  | true -> true
	  | false -> b2
    end.
    \end{lstlisting}
    
    The functions \lstinline!negb! and \lstinline!andb! corresponding to the boolean functions {\emph negation} and {\emph and} are implemented in a similar manner.
     
    And a new symbolic notations is implemented as follows
    \begin{lstlisting}
    Notation "x && y" := (andb x y).
    Notation "x||y" := (orb x y).
    \end{lstlisting}
    
     
\subsection{Notation}
    As in the Coq doc documentation tool the following notation convention is introduced:
     
    \begin{enumerate}
     \item In \texttt{.v-files} comments are annotated by \lstinline!(* some comment *)!. 
     \item Within these comments Coq-code is denoted by \lstinline![example].! 
     \item And we write \lstinline! Admitted.! at the end of an incomplete proof.    
     \end{enumerate}
     
     
\subsection{Types}
     Every expression in Coq has a type.
     \begin{enumerate}
      \item  \lstinline* Check true.* gives the type of the expression \lstinline! boolean!.
      \item \lstinline! Check negb.! returns \lstinline! bool -> bool! . (Read as  ``bool arrow bool'').
           %  It is the functions input data type and the output data type, given input data of that type.
       \item \lstinline! andb! returns \lstinline!bool->bool->bool!. This function produces an output of type \lstinline! bool! given two inputs of type \lstinline! bool!.
     \end{enumerate}
   
\subsection{New Types from Old}
     
     
	 Note that so far the data-types we have seen were enumerated types.
	 Let's define a data type \lstinline!rgb! and a data type, whose constructor takes this type as an argument.
	\begin{lstlisting}
	 Inductive rgb: Type:=
	  | red     (* These are *)
	  | green   (* the expressions *)
	  | blue.   (* in the set [rgb]. *)
	 \end{lstlisting}
	 The constructors of the type \lstinline!rgb! are \lstinline!red, green! and \lstinline!blue!. 
	 
	 \begin{lstlisting}
	 Inductive color: Type := 
	  | black
	  | white
	  | primary (p:rgb). (* If [p] is in the set [rgb], then the constructor [primary] applied to the argument [p] is an expression in the set color.*) 
	 \end{lstlisting}
	 
	 The expressions in the set color are \lstinline!black, white! and \lstinline!primary!.
	 Note that, expressions formed as above are the only ones belonging to the sets \lstinline!rgb! and \lstinline!color!.
	 

\subsection{Tuples}

    A single constructor with multiple parameters can be used to create a type \lstinline! tuple!.
	\begin{example}[A nybble: half a byte]
 	 	\begin{lstlisting}
 	 		Inductive bit: Type := (*a bit*) 
 	 		 |B0
 	 		 |B1.
 		    Inductive nybble: Type := (*a nybble*)
 		   	 |bits( b0 b1 b2 b3: bit).
 		   			 	
 		   	Check(bits B1 B0 B1 B0) (* => bits B1 B0 B1 B0 : nybble *)
 		\end{lstlisting}
 		Hence, a tuple of four bits is a nybble.
 		
 		Assume we would like to test a nybble in order to see if all its bits are 0. We are unwrapping the nybble by patternmatching:
 		\begin{lstlisting}
 		Definition all_zero(nb: nybble): bool :=
 		  match nb with
 	  	    |(bits B0 B0 B0 B0) -> true
 		    |(bits _ _ _ _) -> false (* This wildcard pattern was included to avoid inventing variable names, which are not going to be used. *) 
 		  end.
 		 \end{lstlisting}
 	\end{example}
 	

\subsection{Modules}

	Coq provides a {\itshape module system} to aid organizing large developments.
	In this course most of it is not going to be needed.

	\begin{lstlisting}
	Module X 
	...
	End X
	\end{lstlisting}

\subsection{Numbers}

  Note that on the one hand the types day, bool, bits and tuples have a finite set of values, while on the other hand the set of natural numbers $\mathbb{N}$ is an infinite set.
 
  Hence, we have to construct $\mathbb{N}$ using a data type with a final number of constructors. 
  Recall, many representations of $\mathbb{N}$ exits (e.g. hexadecimal with base 16, octa with base 8, binary with base 2).
  The most familiar might be the decimal representation.\\
  However, each representation of $\mathbb{N}$ can be useful under different circumstances. 
  The binary representation is valuable in computer hardware, because it presents a simple circuitry.
  Here we are aiming to make proofs simple using the unary (base 1) representation.
  
  \begin{lstlisting}
  Module NatPlayground
  Inductive nat: Type :=
    | 0
    | S (n:nat).
  \end{lstlisting}
  
  One might picture this representation by scratches on a wall in prison. \\
  It uses two constructors: 
  \begin{itemize}
  \item The letter \lstinline!0! represents the natural number zero. 
  \item The letter \lstinline!S! represents a natural number $n\in\mathbb{N}\setminus\{ 0\}$.  
  \end{itemize}
  There is a way of converting this representation refereed to as \lstinline!nat! into its decimal representation. This is elaborated as follows.
  \begin{example}
  
	  \begin{tabular} {r l}
	  
		  \texttt{unitary}				& \texttt{decimal}	\\
		  \texttt{\lstinline!0!} 		&: 0 				\\
		  \texttt{\lstinline! S 0!}  	&: 1				\\
		  \texttt{\lstinline! S ( S 0)!}	&: 2				\\
		  \texttt{\lstinline! S( S ( S 0))!}	&: 3				\\
		    
	  \end{tabular}
  \end{example}
  Moreover, it is easy to see the following: 
  \begin{itemize}
  \item The expression \lstinline! 0! belongs to the set \lstinline! nat!.
  \item If \lstinline! n ! is in the set \lstinline! nat!, it follows \lstinline! S n ! is an expression belonging to the set \lstinline! nat !.
  \item And expressions belong the set \lstinline! nat! if and only if they are  formed by either of those methods (i.e. \lstinline! 0 ! or  \lstinline! S n!). 
  \end{itemize}
  
  
  Note that the same results apply to the definitions of \lstinline! day!, \lstinline! bool! and \lstinline! color!.
  These conditions are a precise force of the \lstinline! Inductive! declaration. 
  Expressions adult from other data constructors like \lstinline!true!, \lstinline! false!, \lstinline!andb(S(false( 0 ( 0 S ))))! do not belong to this set.  
  But on the other hand, \lstinline!0! and \lstinline!S! are arbitrary symbols chosen in the defined representation. 
  Actually the {\itshape interpretation} of these marks is given by their usage in computing.
  To realize this functions, which ``pattern match'' a representation of natural numbers, are written.
  
  We are following the idea:  If n has the form \lstinline! Sn'! for some \lstinline! n'! in the set \lstinline!nat!, then return  \lstinline! n'!.
  \begin{example}[predecessor function]
   \begin{lstlisting}
  	 Definition pred (n:nat): nat :=
   		match n with 
   	     | 0 => 0
   	     | S n' => n'
   	    end. 
   	  
   	 End NatPlayground
   	 
   	 check( S(S(S(S(0)))). (* = 4: nat *)
   \end{lstlisting}
  \end{example}
  Because natural numbers are such a pervasive form of data, Coq always prints out a natural number as decimal by default.
  (It uses a tiny `` bulid-in magic'' for paring and printing.)
 
  \begin{lstlisting}
  Definition minustwo( n: nat) : nat :=
    match n with
      | 0 =>  0
      | S 0 =>  0
      | S ( S n') = > n'
     end.
     
   Compute( minustwo(4)) (* = 2: nat *)
  \end{lstlisting}  
  Sofar we have seen the functions \lstinline!S!, \lstinline!pred! and \lstinline!minustwo!.
  Note that, there is a fundamental difference.
  The functions \lstinline!pred! and \lstinline!minustwo! apply computaional rules. 
  There are no computaional rules about \lstinline!S!.
  I.e., by the definition of \lstinline!pred!, \lstinline!pred 2! can be simplified to \lstinline!1!. 
  In the case of \lstinline!S! no such behavior exists.
  The definition of \lstinline!S! has no bahavior at all.\\ 
    
  In order to define more functions over numbers pattern matching is not sufficient. We are introducing recursion.
  Recursion in Coq is notated by the keyword \lstinline!Fixpoint!.
  
  \begin{lstlisting}
  Fixpoint evenb (n:nat) : bool :=
  	match n with
  	| 0 => true
  	| S 0 => false
  	| S (S n') => evenb n'
  	end.
  	
  	Definition oddb (n:nat): bool := negb (even bn). (* a simple definition of odd *)
  	
  	Example test_oddb1: oddb1 = true
    	Proof. simpl. reflexivity. Qed.
  \end{lstlisting}
   Note that in this proof \lstinline!simpl.! actually has no effect on the goal. 
   All the work is done by \lstinline!refelxivity!. 
   We are going to come to back to that later.
   
   \subsection{Multi Argument-Function by Recursion}
   
   \begin{lstlisting}
   Module NatPlayground2.
   
   Fixpoint plus (n : nat) (m : nat): nat :=
     match n with
       | 0 => m
       | S n' => S (plus n' m)
     end.
     
    Compute (plus 3 2). 
   \end{lstlisting}
   
    A notaion convention for calling functions or matching two expressions for multiple arguments of the same type exist in Coq, too.
   
   \begin{lstlisting}
    Fixpoint minus (n m: nat): nat :=
     match n, m with
       | 0 , _ => 0
       | S _ , 0 => n
       | S n', S m' => minus n' m'
      end.
      
     Example test_mult1: (minus 3 2) = 1.
     
      
     End NatPlayground2
   \end{lstlisting}
        
   \subsection{Introducing Notations}


    For the Coq-parsers and Coq-prettifyers sake we are introducing a new notation:
    
    \begin{lstlisting}
     Notation "x+y":= (plus x y)
                      (at level 50, left associatifity) (*This line is not of interest for our purpose.*)
                      : nat_scope. (*This line is not of our interest.*)
    \end{lstlisting} 
   
   And these are some more functions defined for our purpose. 
   The intersterd reader is referend to the literature for an exact definition.  
   
   \begin{center}
   \begin{tabular}{|c|c|c|c|}
     \hline 
 	  used notation & function        & functionality                       & uses           \\  \hline
 	  x - y         & minus           & substract natural numbers           & see snipplet   \\  \hline
      x + y         & plus            & add natural numbers                 & see snipplet   \\  \hline
      x * y         & mult            & multiply natural numbers            & nested matches \\  \hline   
   	  x =? y        & eqb             & test natural numbers                & nested matches \\  
  	                &                 & for equality yielding a boolean     &                \\  \hline
   	  x <=?y        & leb             & test if a first argumnet            & nested matches \\  
   	                &                 & is less or equal yielding a boolean &                \\  \hline
   	 \hline
   \end{tabular}
   \end{center}
   
   \subsection{Proof by Simplification}
   
   
   Till now we have defined a few datatypes and functions.
   Example: We have seen all claims were shown by the same proofs. \lstinline!simple! and \lstinline!refelctivity!. 
   \lstinline!simple! simplifies equations and \lstinline!reflexivity! checks weather both sides contain identical values.
   On the hand rule might say that \lstinline!simple! can be used to show more simple properties.
   For example we are considering the follwing observation:´´ 0+n reduces to n, no matter, what n is.''
   The mathematical precisly formualted statement can be proven by definition of zero directly.
   
   \begin{example}
	   \begin{theorem}
  	   \begin{lstlisting}
   		Theorem. plus_0_n: for n: nat, 0+n = n.
   		Proof. intros n. simpl. refelxivity. Qed.
    	\end{lstlisting}	
	\end{theorem}
	\end{example}              
    \begin{remark}
    	Reflexivity does not only check. It is more powerful. It simplifies, too. 
    	We have seen in our examples simpl just was added so we can see the intermediate state.
    	E.g. the proof from above can be simpliefied. 
     \end{remark}


	\begin{lstlisting}
    Theorem plus_0_n': for all n: nat, 0+n = n.
    proof: intros n. reflexivity. Qed.	
    \end{lstlisting}
    
    Note that \lstinline!example! and \lstinline!theorem! mean pretty much the same in Coq.
    
   
    \paragraph{Prooftechnique}
    \paragraph{Simplification and Reflexivity}
     Whenever a \lstinline!Theorem! starts with \lstinline!for all n!, we might start a proof by the phrase:
     Assume \lstinline!n! is some natural number. By \lstinline! intros n! we can tell that to Coq.\\
     A tactic ia a command used between \lstinline!proof! and \lstinline! Qed.!, which guides the process of checking some claim. E.g.:
	    \begin{lstlisting}
	    	intros. simpl. reflexivity.
    	\end{lstlisting}
     
     \paragraph{Notation} 
     The suffix \lstinline!_|! is pronounced ´´on the left''.  
      \begin{lstlisting}
      Theorem mult_0_l: for all n: nat, or n = 0.
        proof: intros n. refelxivity. Qed.
     \end{lstlisting}
      
     \paragraph{Proof by Rewriting}
     \begin{example}
	 \begin{lstlisting}
	 Theorem plus_id_examples: for all n m: nat
       n = m -> 
	   n+n = m+m.	 
	 \end{lstlisting}     
     Instead by making a claim about all numbers look at the secial case when \lstinline!n=m!.
     \begin{align*}
     \texttt{´´} -> \texttt{''} implies 
     \end{align*}
     the tactic \lstinline! intros!.     
     \end{example}
    
     Note taht the arrow \lstinline!->! tells Coq to rewrite from left to rithz and \lstinline!<-! can be used to rewrite from right to left.
     
     \begin{tabular} {|l|c|l|}
     	\hline
     	command                         & a mathematical translation                       & comment \\  \hline
     	\lstinline!proof.!              & moves the last used theorem into the focus.      & moves the universal quanitivier into the focus  \\ \hline
     	\lstinline!intros n m.!         & Assume $m,n \in \mathbb{N}.$                     &                                                 \\ \hline
    	\lstinline!intros H.!           & $H :=\{n=m\}$                                    & moves hypothesis into the context                \\    \hline                                            \\
     	\lstinline!rewrite -> H.!       & replace by H from left to right                  &                                                 \\  
     	                                & i.e. $n:=m$ $\implies m+m = m+m$                 & rewrite the goal using the hypothesis           \\ \hline
     	\lstinline!reflexivity.!        & use equivalence to show equality                 &                                                 \\ \hline
    	\lstinline!Qed.!                &                                                  &                                                 \\  \hline
    	\hline
     \end{tabular}
   
   
   \begin{definition}[Equivalence Relation]
   Assume $x,y\in \mathcal{M}$ an arbitrary set $\mathcal{M}\neq\emptyset$ and $\tilde{}\subset A \times A $ an arbitrary relation.
   Then $\tilde{}$ is sayed to be an equivalence relation if and only if:
   \begin{enumerate}
   \item $a\tilde{} a$ (reflexivity)
   \item $a\tilde{} b$ if and only if $b \tilde{} c$ (symmertry)
   \item if $a\tilde{} b$ and $ b\tilde{} c$ then $a\tilde{} c$ (transitivity) 
   \end{enumerate}
   \end{definition}
     
   Due to the \href{https://pjreddie.com/coq-tactics/}{Coq tactics index} it is recomended to use refelxivity, if your goal is to prove that something is equals to itself.  
   
   We can also use \lstinline!rewrite! with a previously proved theorem insted of a hypothesis of context.
   If the statement of the previously proved theorem involves prequnatified variables Coq reuses them.
   
   \begin{lstlisting}
   Theorem mult_0_plus: for all n m: nat,
     intros n m. ( 0 +n)* m = n*m. (* Let $n,m\in\mathbb{N}$ *) 
     refelxivity -> plus_0_n.      (* rewrite $0+n$, by n *)
     reflexivity.                  (* m = m *)
     Qed.
   \end{lstlisting}   

	\paragraph{Admitted and Abort}
	
	The comand \llstinline{Admitted} tells Coq to skip a proofing the theorem and accept it as given.
	It can be used in long proof to subsidary state longer \lstinline!Lemmas!  Or a proof was startet it can be interuped by the command \lstinline!Abort!.
	Note if a proof was forgotton in the follwing nonesense might be proven. \\
	
   \paragraph{Destruct}	
	It is not possible to prove everyting using the simplification tactic.   
	\begin{lstlisting}
	intros n. destruct n as[ |n'] eqn: E
	\end{lstlisting}

   