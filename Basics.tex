\section{Basic Functional Programming in Coq}




\subsection{Introduction}

In this chapter we are going to introduce the most essential elements of Coq's functional programming language called {\itshape  Gallina}. 
Moreover, {\itshape tactics}, which can be applied to prove properties of Coq programs, are introduced.


\subsection{Data and Functions}

 \paragraph{Enumerated Type}
 
  The built-in features set in Coq is extremely small. In particular, Coq is a powerful mechanism for defining data types from scratch.
  Current Coq distributions come preloaded with an extensive standard library.
  Bools, numbers, data struts like lists and hash tables.\\
  In this course we are going to explicitly recapitulate the used definitions.
   
  
  \begin{example}
  We are defining a type called \lstinline!day!.
  \begin{lstlisting}
    Inductive day: Type :=
	  | monday
	  | tuesday
	  | wednesday
	  | thursday
	  | friday.
	  | saturday.
	  | sunday.
	  \end{lstlisting} 
  
  The type members are called \lstinline!monday!, \lstinline!tuesday! , \lstinline!wednesday! \ldots{} and \lstinline!sunday!.\\
  
  And define a function operating on it: 
  \begin{lstlisting}
  Definition next_weekday(d:day) day:=
    match d with 
	  | monday => tuesday
	  | tuesday => wednesday
	  | wednesday => thursday
	  | thursday => friday
	  | friday => monday
	  | saturday => monday
	  | sunday => monday.
    end.  
  \end{lstlisting}
  \end{example}

  Coq is able of type {\itshape interference}, whenever the type is not defined explicitly.
  But for readability, we are including types in the following.
   
  For testing the above definition and function we have three possibilities:   
   \begin{enumerate}
   \item Compute a compound expression including the function:\\
   \lstinline! compute (next_weekday friday).! or 
   \lstinline! compute (next_weekday (next_weekday saturday)).!
   \item Record an expected behaviour as a Coq-\lstinline!Example! and verify the assertion: 
         E.g.: {\itshape The second weekday after Saturday is Tuesday.}  
   
		   \begin{lstlisting}
		   		Example. test_next_weekday: (next_weekday (next_weeekday(saturday)) = tuesday 
		   		proof. simpl. reflexivity. Qed.
		   \end{lstlisting}
   			The details of the implementation are not important here. We are going to come back to them later.
   \end{enumerate}   

    Moreover, Coq can be asked to \lstinline!extract! a program in a programming language, which is more conventional, being equipped with a high performance compiler.
    In particular this is one of the main uses of Coq. 
    It provides a method to transfer correct proven algorithms in Gallina to efficient machine code.
    (Assuming the correctness of the corresponding high performance compile e.g.the Ocaml, Haskell or Scheme compiler. 


\subsection{Booleans}

    Of course, Coq provides an default implementation of booleans. (See the \href{https://www.cs.princeton.edu/courses/archive/fall07/cos595/stdlib/html/Coq.Init.Datatypes.html}{Coq.Init.Datatypes Library}). %TODO: add link.
    In the following we are going to be consistent with the Coq library documentation according to the standart library. We are going to introduce coinciding selfdefined datatypes.
    Booleans can be defined as follows:
    
    \label{Def:booleans}
    \begin{lstlisting}    
    Inductive bool: Type :=
    | true
    | false.
    \end{lstlisting}
    
    A function with multiple input arguments is implemented as in the following:
    \begin{lstlisting}
    Definition orb (b1: bool) (b2: bool) : bool :=
    match b1 with
    | true -> true
    | false -> b2
    end.
    \end{lstlisting}
     
    And its new symbolic notation like this:
    \begin{lstlisting}
    Notation "x && y" := (andb x y).
    Notation "x||y" := (orb x y).
    \end{lstlisting}
    
     
\subsection{Notation}
     
    \begin{enumerate}
     \item In \texttt{.v-files} comments are annotated by \lstinline!(* some comment *)!. 
     \item Within these comments Coq-code is denoted by \lstinline![example].! 
     \item And we write \lstinline! Admitted.! at the end of an incomplete proof.    
     \end{enumerate}
     
     
\subsection{Types}

     Every expression has a type.
     \begin{enumerate}
     \item  \lstinline! Check true.! gives the type of the method \lstinline! boolean!.
     \item \lstinline! Check negb.! returns \lstinline! bool -> bool!( read \glqq bool arrow bool\grqq).
      It is the functions input data type and the output data type, given input data of that type.
      \item \lstinline! andb! returns \lstinline!bool->bool->bool!. This function produces an output of type bool given two bools.
     \end{enumerate}
     
\subsection{New Types from old}

	 Let's define a data type \lstinline!rgb!. And a data type, whose constructor takes that type as an argument.
	\begin{lstlisting}
	 Inductive rgb: Type:=
	 | red     (* These are *)
	 | green   (* the expressions *)
	 | blue.   (* in the set [rgb]. *)
	 \end{lstlisting}
	 The constructors of the type \lstinline!rgb! are  \lstinline!red, green! and \lstinline!blue!. 
	 
	 \begin{lstlisting}
	 Inductive color: Type := 
	 | black
	 | white
	 | primary (p:rgb). (* If [p] is in the set [rgb] then the constructor  [primary] applied to the argument [p] is an expression in the set color.*) 
	 \end{lstlisting}
	 
	 The expressions in the set color are \lstinline!black, white! and \lstinline!primary!.
	 Note that, expressions formed in these ways (as above) are the only ones belonging to the sets \lstinline!rgb! and \lstinline!color!.
	 

\subsection{Tuples}

    A single constructor with multiple parameters is of type \lstinline! tuple!.
	\begin{example}[A nybble: half a byte]
 	 	\begin{lstlisting}
 	 		(*a bit*)    Inductive bit: Type := 
 	 						|B0
 	 						|B1.
 		    (*a nybble*) Inductive nybble: Type := 
 		   				 	|bits( b0 b1 b2 b3: bit).
 		   				 	
 		   	check( bits B1 B0 B1 B0)
 		\end{lstlisting}
 		Hence, a tuple of four bits as a nybble.
 		
 		Assume we want to test a nybble to see if all its bits are 0. We unwrapp the nybble by patternmatching.
 		\begin{lstlisting}
 		Definition all_zero(nb: nybble): bool :=
 		  match nb with
 		  |(bits B0 B0 B0 B0) -> true
 		  |(bits _ _ _ _) -> false ( * This wildcard pattern got included to advoid inventing variable names that will not be used. *) 
 		  end.
 		 \end{lstlisting}
 	\end{example}
 	

\subsection{Modules}
	Coq provides a module system (organizing large development) in this course we won't need most of it.
	\begin{lstlisting}
	Module X 
	...
	End X.
	\end{lstlisting}

\subsection{Numbers}
 \begin{itemize}
 \item[]Note that the types day, bool, bits and tuples have a finite set of values, 
 \item[] while the set of natural numbers $\mathbb{N}$ is an infinite set.
 \end{itemize}
  Hence, we need to construct $\mathbb{N}$ using a datatype with a final number of constructors. 
  Recall that many representations exits (e.g. hexadecimal with base 16, octa with base 8, binary with base 2).
  The most familiar is the decimal representation.
  However, each representation of $\mathbb{N}$ is useful under different circumstances. 
  he binary representation is well available in computer hardware, since it presents a simple circuitry.
  Here we would like to make proofs simple using the unary (base 1) representation.
  
  \begin{lstlisting}
  Inductive nat: Type :=
  | 0
  | S (n:nat).
  \end{lstlisting}
  
  One might picture this representation by scratches on a wall in prison. It uses two constructors: 
  \begin{itemize}
  \item the letter \lstinline!0! represents zero 
  \item the letter \lstinline!S! represents a natural number $n\in\mathbb{N}_{\setminus 0}$.  
  \end{itemize}
  We can convert this represntaion into decimal represented number as in the following.
  \begin{example}
  \begin{align*}
  \texttt{unitary}				& \texttt{decimal}	\\
  \texttt{\lstinline!0!} 		&: 0 				\\
  \texttt{\lstinline! S 0!}  	&: 1				\\
  \texttt{\lstinline! S(S0)!}	&: 2				\\
  \end{align*}
  \end{example}
  Moreover, it is easy to see that if $n$ is in the set \lstinline! nat! is in the set it follows \lstinline! S n ! is an expression belonging to the set \lstinline! nat !.
  And Expressions formed by these two ways (i.e. \lstinline! 0 ! / \lstinline! Sn! are the only ones belonging the the set \lstinline! nat!. 